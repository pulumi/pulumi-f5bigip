// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * `f5bigip.NetTunnel` Manages a tunnel configuration
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as f5bigip from "@pulumi/f5bigip";
 *
 * const example1 = new f5bigip.NetTunnel("example1", {
 *     name: "example1",
 *     localAddress: "192.16.81.240",
 *     profile: "/Common/dslite",
 * });
 * ```
 */
export class NetTunnel extends pulumi.CustomResource {
    /**
     * Get an existing NetTunnel resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: NetTunnelState, opts?: pulumi.CustomResourceOptions): NetTunnel {
        return new NetTunnel(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'f5bigip:index/netTunnel:NetTunnel';

    /**
     * Returns true if the given object is an instance of NetTunnel.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is NetTunnel {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === NetTunnel.__pulumiType;
    }

    /**
     * The application service that the object belongs to
     */
    declare public readonly appService: pulumi.Output<string | undefined>;
    /**
     * Specifies whether auto lasthop is enabled or not
     */
    declare public readonly autoLastHop: pulumi.Output<string | undefined>;
    /**
     * User defined description
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Specifies an idle timeout for wildcard tunnels in seconds
     */
    declare public readonly idleTimeout: pulumi.Output<number | undefined>;
    /**
     * The key field may represent different values depending on the type of the tunnel
     */
    declare public readonly key: pulumi.Output<number | undefined>;
    /**
     * Specifies a local IP address. This option is required
     */
    declare public readonly localAddress: pulumi.Output<string>;
    /**
     * Specifies how the tunnel carries traffic
     */
    declare public readonly mode: pulumi.Output<string | undefined>;
    /**
     * Specifies the maximum transmission unit (MTU) of the tunnel
     */
    declare public readonly mtu: pulumi.Output<number | undefined>;
    /**
     * Name of the tunnel
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Displays the admin-partition within which this component resides
     */
    declare public readonly partition: pulumi.Output<string | undefined>;
    /**
     * Specifies the profile that you want to associate with the tunnel
     */
    declare public readonly profile: pulumi.Output<string>;
    /**
     * Specifies a remote IP address
     */
    declare public readonly remoteAddress: pulumi.Output<string | undefined>;
    /**
     * Specifies a secondary non-floating IP address when the local-address is set to a floating address
     */
    declare public readonly secondaryAddress: pulumi.Output<string | undefined>;
    /**
     * Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
     */
    declare public readonly tos: pulumi.Output<string | undefined>;
    /**
     * Specifies a traffic-group for use with the tunnel
     */
    declare public readonly trafficGroup: pulumi.Output<string | undefined>;
    /**
     * Enables or disables the tunnel to be transparent
     */
    declare public readonly transparent: pulumi.Output<string | undefined>;
    /**
     * Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
     */
    declare public readonly usePmtu: pulumi.Output<string | undefined>;

    /**
     * Create a NetTunnel resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: NetTunnelArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: NetTunnelArgs | NetTunnelState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as NetTunnelState | undefined;
            resourceInputs["appService"] = state?.appService;
            resourceInputs["autoLastHop"] = state?.autoLastHop;
            resourceInputs["description"] = state?.description;
            resourceInputs["idleTimeout"] = state?.idleTimeout;
            resourceInputs["key"] = state?.key;
            resourceInputs["localAddress"] = state?.localAddress;
            resourceInputs["mode"] = state?.mode;
            resourceInputs["mtu"] = state?.mtu;
            resourceInputs["name"] = state?.name;
            resourceInputs["partition"] = state?.partition;
            resourceInputs["profile"] = state?.profile;
            resourceInputs["remoteAddress"] = state?.remoteAddress;
            resourceInputs["secondaryAddress"] = state?.secondaryAddress;
            resourceInputs["tos"] = state?.tos;
            resourceInputs["trafficGroup"] = state?.trafficGroup;
            resourceInputs["transparent"] = state?.transparent;
            resourceInputs["usePmtu"] = state?.usePmtu;
        } else {
            const args = argsOrState as NetTunnelArgs | undefined;
            if (args?.localAddress === undefined && !opts.urn) {
                throw new Error("Missing required property 'localAddress'");
            }
            if (args?.name === undefined && !opts.urn) {
                throw new Error("Missing required property 'name'");
            }
            if (args?.profile === undefined && !opts.urn) {
                throw new Error("Missing required property 'profile'");
            }
            resourceInputs["appService"] = args?.appService;
            resourceInputs["autoLastHop"] = args?.autoLastHop;
            resourceInputs["description"] = args?.description;
            resourceInputs["idleTimeout"] = args?.idleTimeout;
            resourceInputs["key"] = args?.key;
            resourceInputs["localAddress"] = args?.localAddress;
            resourceInputs["mode"] = args?.mode;
            resourceInputs["mtu"] = args?.mtu;
            resourceInputs["name"] = args?.name;
            resourceInputs["partition"] = args?.partition;
            resourceInputs["profile"] = args?.profile;
            resourceInputs["remoteAddress"] = args?.remoteAddress;
            resourceInputs["secondaryAddress"] = args?.secondaryAddress;
            resourceInputs["tos"] = args?.tos;
            resourceInputs["trafficGroup"] = args?.trafficGroup;
            resourceInputs["transparent"] = args?.transparent;
            resourceInputs["usePmtu"] = args?.usePmtu;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(NetTunnel.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering NetTunnel resources.
 */
export interface NetTunnelState {
    /**
     * The application service that the object belongs to
     */
    appService?: pulumi.Input<string>;
    /**
     * Specifies whether auto lasthop is enabled or not
     */
    autoLastHop?: pulumi.Input<string>;
    /**
     * User defined description
     */
    description?: pulumi.Input<string>;
    /**
     * Specifies an idle timeout for wildcard tunnels in seconds
     */
    idleTimeout?: pulumi.Input<number>;
    /**
     * The key field may represent different values depending on the type of the tunnel
     */
    key?: pulumi.Input<number>;
    /**
     * Specifies a local IP address. This option is required
     */
    localAddress?: pulumi.Input<string>;
    /**
     * Specifies how the tunnel carries traffic
     */
    mode?: pulumi.Input<string>;
    /**
     * Specifies the maximum transmission unit (MTU) of the tunnel
     */
    mtu?: pulumi.Input<number>;
    /**
     * Name of the tunnel
     */
    name?: pulumi.Input<string>;
    /**
     * Displays the admin-partition within which this component resides
     */
    partition?: pulumi.Input<string>;
    /**
     * Specifies the profile that you want to associate with the tunnel
     */
    profile?: pulumi.Input<string>;
    /**
     * Specifies a remote IP address
     */
    remoteAddress?: pulumi.Input<string>;
    /**
     * Specifies a secondary non-floating IP address when the local-address is set to a floating address
     */
    secondaryAddress?: pulumi.Input<string>;
    /**
     * Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
     */
    tos?: pulumi.Input<string>;
    /**
     * Specifies a traffic-group for use with the tunnel
     */
    trafficGroup?: pulumi.Input<string>;
    /**
     * Enables or disables the tunnel to be transparent
     */
    transparent?: pulumi.Input<string>;
    /**
     * Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
     */
    usePmtu?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a NetTunnel resource.
 */
export interface NetTunnelArgs {
    /**
     * The application service that the object belongs to
     */
    appService?: pulumi.Input<string>;
    /**
     * Specifies whether auto lasthop is enabled or not
     */
    autoLastHop?: pulumi.Input<string>;
    /**
     * User defined description
     */
    description?: pulumi.Input<string>;
    /**
     * Specifies an idle timeout for wildcard tunnels in seconds
     */
    idleTimeout?: pulumi.Input<number>;
    /**
     * The key field may represent different values depending on the type of the tunnel
     */
    key?: pulumi.Input<number>;
    /**
     * Specifies a local IP address. This option is required
     */
    localAddress: pulumi.Input<string>;
    /**
     * Specifies how the tunnel carries traffic
     */
    mode?: pulumi.Input<string>;
    /**
     * Specifies the maximum transmission unit (MTU) of the tunnel
     */
    mtu?: pulumi.Input<number>;
    /**
     * Name of the tunnel
     */
    name: pulumi.Input<string>;
    /**
     * Displays the admin-partition within which this component resides
     */
    partition?: pulumi.Input<string>;
    /**
     * Specifies the profile that you want to associate with the tunnel
     */
    profile: pulumi.Input<string>;
    /**
     * Specifies a remote IP address
     */
    remoteAddress?: pulumi.Input<string>;
    /**
     * Specifies a secondary non-floating IP address when the local-address is set to a floating address
     */
    secondaryAddress?: pulumi.Input<string>;
    /**
     * Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
     */
    tos?: pulumi.Input<string>;
    /**
     * Specifies a traffic-group for use with the tunnel
     */
    trafficGroup?: pulumi.Input<string>;
    /**
     * Enables or disables the tunnel to be transparent
     */
    transparent?: pulumi.Input<string>;
    /**
     * Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
     */
    usePmtu?: pulumi.Input<string>;
}
