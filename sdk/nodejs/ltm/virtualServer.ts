// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * `f5bigip.ltm.VirtualServer` Configures Virtual Server
 *
 * For resources should be named with their `full path`. The full path is the combination of the `partition + name` of the resource (example: `/Common/test-virtualserver` ) or `partition + directory + name` of the resource (example: `/Common/test/test-virtualserver` ).
 * When including directory in `fullpath` we have to make sure it is created in the given partition before using it.
 *
 * ## Importing
 *
 * An existing virtual-server can be imported into this resource by supplying virtual-server Name in `full path` as `id`.
 * An example is below:
 * ```sh
 * $ terraform import bigip_ltm_virtual_server.http /Common/terraform_vs_http
 * ```
 */
export class VirtualServer extends pulumi.CustomResource {
    /**
     * Get an existing VirtualServer resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: VirtualServerState, opts?: pulumi.CustomResourceOptions): VirtualServer {
        return new VirtualServer(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'f5bigip:ltm/virtualServer:VirtualServer';

    /**
     * Returns true if the given object is an instance of VirtualServer.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is VirtualServer {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === VirtualServer.__pulumiType;
    }

    /**
     * List of client context profiles associated on the virtual server. Not mutually exclusive with profiles and server_profiles
     */
    public readonly clientProfiles!: pulumi.Output<string[] | undefined>;
    public readonly defaultPersistenceProfile!: pulumi.Output<string>;
    /**
     * Description of Virtual server
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * Destination IP
     */
    public readonly destination!: pulumi.Output<string | undefined>;
    /**
     * Specifies a fallback persistence profile for the Virtual Server to use when the default persistence profile is not available.
     */
    public readonly fallbackPersistenceProfile!: pulumi.Output<string>;
    /**
     * Applies the specified AFM policy to the virtual in an enforcing way,when creating a new virtual, if this parameter is not specified, the enforced is disabled.This should be in full path ex: `/Common/afm-test-policy`.
     */
    public readonly firewallEnforcedPolicy!: pulumi.Output<string>;
    /**
     * Specifies a network protocol name you want the system to use to direct traffic on this virtual server. The default is `tcp`. valid options are [`any`,`udp`,`tcp`]
     */
    public readonly ipProtocol!: pulumi.Output<string | undefined>;
    /**
     * The iRules list you want run on this virtual server. iRules help automate the intercepting, processing, and routing of application traffic.
     */
    public readonly irules!: pulumi.Output<string[] | undefined>;
    /**
     * Mask can either be in CIDR notation or decimal, i.e.: 24 or 255.255.255.0. A CIDR mask of 0 is the same as 0.0.0.0
     */
    public readonly mask!: pulumi.Output<string>;
    /**
     * Name of the virtual server
     */
    public readonly name!: pulumi.Output<string>;
    public readonly perFlowRequestAccessPolicy!: pulumi.Output<string>;
    /**
     * List of persistence profiles associated with the Virtual Server.
     */
    public readonly persistenceProfiles!: pulumi.Output<string[] | undefined>;
    /**
     * Specifies the policies for the virtual server.
     */
    public readonly policies!: pulumi.Output<string[] | undefined>;
    /**
     * Default pool name
     */
    public readonly pool!: pulumi.Output<string | undefined>;
    /**
     * Listen port for the virtual server
     */
    public readonly port!: pulumi.Output<number>;
    /**
     * List of profiles associated both client and server contexts on the virtual server. This includes protocol, ssl, http, etc.
     */
    public readonly profiles!: pulumi.Output<string[]>;
    /**
     * Specifies the log profile applied to the virtual server.
     */
    public readonly securityLogProfiles!: pulumi.Output<string[] | undefined>;
    /**
     * List of server context profiles associated on the virtual server. Not mutually exclusive with profiles and client_profiles
     */
    public readonly serverProfiles!: pulumi.Output<string[] | undefined>;
    /**
     * Specifies the name of an existing SNAT pool that you want the virtual server to use to implement selective and intelligent SNATs.
     */
    public readonly snatpool!: pulumi.Output<string>;
    /**
     * Specifies an IP address or network from which the virtual server will accept traffic.
     */
    public readonly source!: pulumi.Output<string>;
    /**
     * Can be either omitted for `none` or the values `automap` options : [`snat`,`automap`,`none`].
     */
    public readonly sourceAddressTranslation!: pulumi.Output<string>;
    /**
     * Specifies whether the system preserves the source port of the connection. The default is `preserve`.
     */
    public readonly sourcePort!: pulumi.Output<string>;
    /**
     * Specifies whether the virtual server and its resources are available for load balancing. The default is Enabled
     */
    public readonly state!: pulumi.Output<string | undefined>;
    /**
     * Specifies destination traffic matching information to which the virtual server sends traffic
     */
    public readonly trafficmatchingCriteria!: pulumi.Output<string>;
    /**
     * Enables or disables address translation for the virtual server. Turn address translation off for a virtual server if you want to use the virtual server to load balance connections to any address. This option is useful when the system is load balancing devices that have the same IP address.
     */
    public readonly translateAddress!: pulumi.Output<string | undefined>;
    /**
     * Enables or disables port translation. Turn port translation off for a virtual server if you want to use the virtual server to load balance connections to any service
     */
    public readonly translatePort!: pulumi.Output<string | undefined>;
    /**
     * The virtual server is enabled/disabled on this set of VLANs,enable/disabled will be desided by attribute `vlanEnabled`
     */
    public readonly vlans!: pulumi.Output<string[] | undefined>;
    /**
     * Enables the virtual server on the VLANs specified by the `vlans` option.
     * By default it is `false` i.e vlanDisabled on specified vlans, if we want enable virtual server on VLANs specified by `vlans`, mark this attribute to `true`.
     */
    public readonly vlansEnabled!: pulumi.Output<boolean | undefined>;

    /**
     * Create a VirtualServer resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: VirtualServerArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: VirtualServerArgs | VirtualServerState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as VirtualServerState | undefined;
            resourceInputs["clientProfiles"] = state ? state.clientProfiles : undefined;
            resourceInputs["defaultPersistenceProfile"] = state ? state.defaultPersistenceProfile : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["destination"] = state ? state.destination : undefined;
            resourceInputs["fallbackPersistenceProfile"] = state ? state.fallbackPersistenceProfile : undefined;
            resourceInputs["firewallEnforcedPolicy"] = state ? state.firewallEnforcedPolicy : undefined;
            resourceInputs["ipProtocol"] = state ? state.ipProtocol : undefined;
            resourceInputs["irules"] = state ? state.irules : undefined;
            resourceInputs["mask"] = state ? state.mask : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["perFlowRequestAccessPolicy"] = state ? state.perFlowRequestAccessPolicy : undefined;
            resourceInputs["persistenceProfiles"] = state ? state.persistenceProfiles : undefined;
            resourceInputs["policies"] = state ? state.policies : undefined;
            resourceInputs["pool"] = state ? state.pool : undefined;
            resourceInputs["port"] = state ? state.port : undefined;
            resourceInputs["profiles"] = state ? state.profiles : undefined;
            resourceInputs["securityLogProfiles"] = state ? state.securityLogProfiles : undefined;
            resourceInputs["serverProfiles"] = state ? state.serverProfiles : undefined;
            resourceInputs["snatpool"] = state ? state.snatpool : undefined;
            resourceInputs["source"] = state ? state.source : undefined;
            resourceInputs["sourceAddressTranslation"] = state ? state.sourceAddressTranslation : undefined;
            resourceInputs["sourcePort"] = state ? state.sourcePort : undefined;
            resourceInputs["state"] = state ? state.state : undefined;
            resourceInputs["trafficmatchingCriteria"] = state ? state.trafficmatchingCriteria : undefined;
            resourceInputs["translateAddress"] = state ? state.translateAddress : undefined;
            resourceInputs["translatePort"] = state ? state.translatePort : undefined;
            resourceInputs["vlans"] = state ? state.vlans : undefined;
            resourceInputs["vlansEnabled"] = state ? state.vlansEnabled : undefined;
        } else {
            const args = argsOrState as VirtualServerArgs | undefined;
            if ((!args || args.name === undefined) && !opts.urn) {
                throw new Error("Missing required property 'name'");
            }
            resourceInputs["clientProfiles"] = args ? args.clientProfiles : undefined;
            resourceInputs["defaultPersistenceProfile"] = args ? args.defaultPersistenceProfile : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["destination"] = args ? args.destination : undefined;
            resourceInputs["fallbackPersistenceProfile"] = args ? args.fallbackPersistenceProfile : undefined;
            resourceInputs["firewallEnforcedPolicy"] = args ? args.firewallEnforcedPolicy : undefined;
            resourceInputs["ipProtocol"] = args ? args.ipProtocol : undefined;
            resourceInputs["irules"] = args ? args.irules : undefined;
            resourceInputs["mask"] = args ? args.mask : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["perFlowRequestAccessPolicy"] = args ? args.perFlowRequestAccessPolicy : undefined;
            resourceInputs["persistenceProfiles"] = args ? args.persistenceProfiles : undefined;
            resourceInputs["policies"] = args ? args.policies : undefined;
            resourceInputs["pool"] = args ? args.pool : undefined;
            resourceInputs["port"] = args ? args.port : undefined;
            resourceInputs["profiles"] = args ? args.profiles : undefined;
            resourceInputs["securityLogProfiles"] = args ? args.securityLogProfiles : undefined;
            resourceInputs["serverProfiles"] = args ? args.serverProfiles : undefined;
            resourceInputs["snatpool"] = args ? args.snatpool : undefined;
            resourceInputs["source"] = args ? args.source : undefined;
            resourceInputs["sourceAddressTranslation"] = args ? args.sourceAddressTranslation : undefined;
            resourceInputs["sourcePort"] = args ? args.sourcePort : undefined;
            resourceInputs["state"] = args ? args.state : undefined;
            resourceInputs["trafficmatchingCriteria"] = args ? args.trafficmatchingCriteria : undefined;
            resourceInputs["translateAddress"] = args ? args.translateAddress : undefined;
            resourceInputs["translatePort"] = args ? args.translatePort : undefined;
            resourceInputs["vlans"] = args ? args.vlans : undefined;
            resourceInputs["vlansEnabled"] = args ? args.vlansEnabled : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(VirtualServer.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering VirtualServer resources.
 */
export interface VirtualServerState {
    /**
     * List of client context profiles associated on the virtual server. Not mutually exclusive with profiles and server_profiles
     */
    clientProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    defaultPersistenceProfile?: pulumi.Input<string>;
    /**
     * Description of Virtual server
     */
    description?: pulumi.Input<string>;
    /**
     * Destination IP
     */
    destination?: pulumi.Input<string>;
    /**
     * Specifies a fallback persistence profile for the Virtual Server to use when the default persistence profile is not available.
     */
    fallbackPersistenceProfile?: pulumi.Input<string>;
    /**
     * Applies the specified AFM policy to the virtual in an enforcing way,when creating a new virtual, if this parameter is not specified, the enforced is disabled.This should be in full path ex: `/Common/afm-test-policy`.
     */
    firewallEnforcedPolicy?: pulumi.Input<string>;
    /**
     * Specifies a network protocol name you want the system to use to direct traffic on this virtual server. The default is `tcp`. valid options are [`any`,`udp`,`tcp`]
     */
    ipProtocol?: pulumi.Input<string>;
    /**
     * The iRules list you want run on this virtual server. iRules help automate the intercepting, processing, and routing of application traffic.
     */
    irules?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Mask can either be in CIDR notation or decimal, i.e.: 24 or 255.255.255.0. A CIDR mask of 0 is the same as 0.0.0.0
     */
    mask?: pulumi.Input<string>;
    /**
     * Name of the virtual server
     */
    name?: pulumi.Input<string>;
    perFlowRequestAccessPolicy?: pulumi.Input<string>;
    /**
     * List of persistence profiles associated with the Virtual Server.
     */
    persistenceProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies the policies for the virtual server.
     */
    policies?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Default pool name
     */
    pool?: pulumi.Input<string>;
    /**
     * Listen port for the virtual server
     */
    port?: pulumi.Input<number>;
    /**
     * List of profiles associated both client and server contexts on the virtual server. This includes protocol, ssl, http, etc.
     */
    profiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies the log profile applied to the virtual server.
     */
    securityLogProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of server context profiles associated on the virtual server. Not mutually exclusive with profiles and client_profiles
     */
    serverProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies the name of an existing SNAT pool that you want the virtual server to use to implement selective and intelligent SNATs.
     */
    snatpool?: pulumi.Input<string>;
    /**
     * Specifies an IP address or network from which the virtual server will accept traffic.
     */
    source?: pulumi.Input<string>;
    /**
     * Can be either omitted for `none` or the values `automap` options : [`snat`,`automap`,`none`].
     */
    sourceAddressTranslation?: pulumi.Input<string>;
    /**
     * Specifies whether the system preserves the source port of the connection. The default is `preserve`.
     */
    sourcePort?: pulumi.Input<string>;
    /**
     * Specifies whether the virtual server and its resources are available for load balancing. The default is Enabled
     */
    state?: pulumi.Input<string>;
    /**
     * Specifies destination traffic matching information to which the virtual server sends traffic
     */
    trafficmatchingCriteria?: pulumi.Input<string>;
    /**
     * Enables or disables address translation for the virtual server. Turn address translation off for a virtual server if you want to use the virtual server to load balance connections to any address. This option is useful when the system is load balancing devices that have the same IP address.
     */
    translateAddress?: pulumi.Input<string>;
    /**
     * Enables or disables port translation. Turn port translation off for a virtual server if you want to use the virtual server to load balance connections to any service
     */
    translatePort?: pulumi.Input<string>;
    /**
     * The virtual server is enabled/disabled on this set of VLANs,enable/disabled will be desided by attribute `vlanEnabled`
     */
    vlans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enables the virtual server on the VLANs specified by the `vlans` option.
     * By default it is `false` i.e vlanDisabled on specified vlans, if we want enable virtual server on VLANs specified by `vlans`, mark this attribute to `true`.
     */
    vlansEnabled?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a VirtualServer resource.
 */
export interface VirtualServerArgs {
    /**
     * List of client context profiles associated on the virtual server. Not mutually exclusive with profiles and server_profiles
     */
    clientProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    defaultPersistenceProfile?: pulumi.Input<string>;
    /**
     * Description of Virtual server
     */
    description?: pulumi.Input<string>;
    /**
     * Destination IP
     */
    destination?: pulumi.Input<string>;
    /**
     * Specifies a fallback persistence profile for the Virtual Server to use when the default persistence profile is not available.
     */
    fallbackPersistenceProfile?: pulumi.Input<string>;
    /**
     * Applies the specified AFM policy to the virtual in an enforcing way,when creating a new virtual, if this parameter is not specified, the enforced is disabled.This should be in full path ex: `/Common/afm-test-policy`.
     */
    firewallEnforcedPolicy?: pulumi.Input<string>;
    /**
     * Specifies a network protocol name you want the system to use to direct traffic on this virtual server. The default is `tcp`. valid options are [`any`,`udp`,`tcp`]
     */
    ipProtocol?: pulumi.Input<string>;
    /**
     * The iRules list you want run on this virtual server. iRules help automate the intercepting, processing, and routing of application traffic.
     */
    irules?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Mask can either be in CIDR notation or decimal, i.e.: 24 or 255.255.255.0. A CIDR mask of 0 is the same as 0.0.0.0
     */
    mask?: pulumi.Input<string>;
    /**
     * Name of the virtual server
     */
    name: pulumi.Input<string>;
    perFlowRequestAccessPolicy?: pulumi.Input<string>;
    /**
     * List of persistence profiles associated with the Virtual Server.
     */
    persistenceProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies the policies for the virtual server.
     */
    policies?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Default pool name
     */
    pool?: pulumi.Input<string>;
    /**
     * Listen port for the virtual server
     */
    port?: pulumi.Input<number>;
    /**
     * List of profiles associated both client and server contexts on the virtual server. This includes protocol, ssl, http, etc.
     */
    profiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies the log profile applied to the virtual server.
     */
    securityLogProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of server context profiles associated on the virtual server. Not mutually exclusive with profiles and client_profiles
     */
    serverProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies the name of an existing SNAT pool that you want the virtual server to use to implement selective and intelligent SNATs.
     */
    snatpool?: pulumi.Input<string>;
    /**
     * Specifies an IP address or network from which the virtual server will accept traffic.
     */
    source?: pulumi.Input<string>;
    /**
     * Can be either omitted for `none` or the values `automap` options : [`snat`,`automap`,`none`].
     */
    sourceAddressTranslation?: pulumi.Input<string>;
    /**
     * Specifies whether the system preserves the source port of the connection. The default is `preserve`.
     */
    sourcePort?: pulumi.Input<string>;
    /**
     * Specifies whether the virtual server and its resources are available for load balancing. The default is Enabled
     */
    state?: pulumi.Input<string>;
    /**
     * Specifies destination traffic matching information to which the virtual server sends traffic
     */
    trafficmatchingCriteria?: pulumi.Input<string>;
    /**
     * Enables or disables address translation for the virtual server. Turn address translation off for a virtual server if you want to use the virtual server to load balance connections to any address. This option is useful when the system is load balancing devices that have the same IP address.
     */
    translateAddress?: pulumi.Input<string>;
    /**
     * Enables or disables port translation. Turn port translation off for a virtual server if you want to use the virtual server to load balance connections to any service
     */
    translatePort?: pulumi.Input<string>;
    /**
     * The virtual server is enabled/disabled on this set of VLANs,enable/disabled will be desided by attribute `vlanEnabled`
     */
    vlans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enables the virtual server on the VLANs specified by the `vlans` option.
     * By default it is `false` i.e vlanDisabled on specified vlans, if we want enable virtual server on VLANs specified by `vlans`, mark this attribute to `true`.
     */
    vlansEnabled?: pulumi.Input<boolean>;
}
