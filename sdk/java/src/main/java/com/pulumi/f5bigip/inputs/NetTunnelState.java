// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.f5bigip.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NetTunnelState extends com.pulumi.resources.ResourceArgs {

    public static final NetTunnelState Empty = new NetTunnelState();

    /**
     * The application service that the object belongs to
     * 
     */
    @Import(name="appService")
    private @Nullable Output<String> appService;

    /**
     * @return The application service that the object belongs to
     * 
     */
    public Optional<Output<String>> appService() {
        return Optional.ofNullable(this.appService);
    }

    /**
     * Specifies whether auto lasthop is enabled or not
     * 
     */
    @Import(name="autoLastHop")
    private @Nullable Output<String> autoLastHop;

    /**
     * @return Specifies whether auto lasthop is enabled or not
     * 
     */
    public Optional<Output<String>> autoLastHop() {
        return Optional.ofNullable(this.autoLastHop);
    }

    /**
     * User defined description
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return User defined description
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Specifies an idle timeout for wildcard tunnels in seconds
     * 
     */
    @Import(name="idleTimeout")
    private @Nullable Output<Integer> idleTimeout;

    /**
     * @return Specifies an idle timeout for wildcard tunnels in seconds
     * 
     */
    public Optional<Output<Integer>> idleTimeout() {
        return Optional.ofNullable(this.idleTimeout);
    }

    /**
     * The key field may represent different values depending on the type of the tunnel
     * 
     */
    @Import(name="key")
    private @Nullable Output<Integer> key;

    /**
     * @return The key field may represent different values depending on the type of the tunnel
     * 
     */
    public Optional<Output<Integer>> key() {
        return Optional.ofNullable(this.key);
    }

    /**
     * Specifies a local IP address. This option is required
     * 
     */
    @Import(name="localAddress")
    private @Nullable Output<String> localAddress;

    /**
     * @return Specifies a local IP address. This option is required
     * 
     */
    public Optional<Output<String>> localAddress() {
        return Optional.ofNullable(this.localAddress);
    }

    /**
     * Specifies how the tunnel carries traffic
     * 
     */
    @Import(name="mode")
    private @Nullable Output<String> mode;

    /**
     * @return Specifies how the tunnel carries traffic
     * 
     */
    public Optional<Output<String>> mode() {
        return Optional.ofNullable(this.mode);
    }

    /**
     * Specifies the maximum transmission unit (MTU) of the tunnel
     * 
     */
    @Import(name="mtu")
    private @Nullable Output<Integer> mtu;

    /**
     * @return Specifies the maximum transmission unit (MTU) of the tunnel
     * 
     */
    public Optional<Output<Integer>> mtu() {
        return Optional.ofNullable(this.mtu);
    }

    /**
     * Name of the tunnel
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the tunnel
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Displays the admin-partition within which this component resides
     * 
     */
    @Import(name="partition")
    private @Nullable Output<String> partition;

    /**
     * @return Displays the admin-partition within which this component resides
     * 
     */
    public Optional<Output<String>> partition() {
        return Optional.ofNullable(this.partition);
    }

    /**
     * Specifies the profile that you want to associate with the tunnel
     * 
     */
    @Import(name="profile")
    private @Nullable Output<String> profile;

    /**
     * @return Specifies the profile that you want to associate with the tunnel
     * 
     */
    public Optional<Output<String>> profile() {
        return Optional.ofNullable(this.profile);
    }

    /**
     * Specifies a remote IP address
     * 
     */
    @Import(name="remoteAddress")
    private @Nullable Output<String> remoteAddress;

    /**
     * @return Specifies a remote IP address
     * 
     */
    public Optional<Output<String>> remoteAddress() {
        return Optional.ofNullable(this.remoteAddress);
    }

    /**
     * Specifies a secondary non-floating IP address when the local-address is set to a floating address
     * 
     */
    @Import(name="secondaryAddress")
    private @Nullable Output<String> secondaryAddress;

    /**
     * @return Specifies a secondary non-floating IP address when the local-address is set to a floating address
     * 
     */
    public Optional<Output<String>> secondaryAddress() {
        return Optional.ofNullable(this.secondaryAddress);
    }

    /**
     * Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
     * 
     */
    @Import(name="tos")
    private @Nullable Output<String> tos;

    /**
     * @return Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
     * 
     */
    public Optional<Output<String>> tos() {
        return Optional.ofNullable(this.tos);
    }

    /**
     * Specifies a traffic-group for use with the tunnel
     * 
     */
    @Import(name="trafficGroup")
    private @Nullable Output<String> trafficGroup;

    /**
     * @return Specifies a traffic-group for use with the tunnel
     * 
     */
    public Optional<Output<String>> trafficGroup() {
        return Optional.ofNullable(this.trafficGroup);
    }

    /**
     * Enables or disables the tunnel to be transparent
     * 
     */
    @Import(name="transparent")
    private @Nullable Output<String> transparent;

    /**
     * @return Enables or disables the tunnel to be transparent
     * 
     */
    public Optional<Output<String>> transparent() {
        return Optional.ofNullable(this.transparent);
    }

    /**
     * Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
     * 
     */
    @Import(name="usePmtu")
    private @Nullable Output<String> usePmtu;

    /**
     * @return Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
     * 
     */
    public Optional<Output<String>> usePmtu() {
        return Optional.ofNullable(this.usePmtu);
    }

    private NetTunnelState() {}

    private NetTunnelState(NetTunnelState $) {
        this.appService = $.appService;
        this.autoLastHop = $.autoLastHop;
        this.description = $.description;
        this.idleTimeout = $.idleTimeout;
        this.key = $.key;
        this.localAddress = $.localAddress;
        this.mode = $.mode;
        this.mtu = $.mtu;
        this.name = $.name;
        this.partition = $.partition;
        this.profile = $.profile;
        this.remoteAddress = $.remoteAddress;
        this.secondaryAddress = $.secondaryAddress;
        this.tos = $.tos;
        this.trafficGroup = $.trafficGroup;
        this.transparent = $.transparent;
        this.usePmtu = $.usePmtu;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NetTunnelState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NetTunnelState $;

        public Builder() {
            $ = new NetTunnelState();
        }

        public Builder(NetTunnelState defaults) {
            $ = new NetTunnelState(Objects.requireNonNull(defaults));
        }

        /**
         * @param appService The application service that the object belongs to
         * 
         * @return builder
         * 
         */
        public Builder appService(@Nullable Output<String> appService) {
            $.appService = appService;
            return this;
        }

        /**
         * @param appService The application service that the object belongs to
         * 
         * @return builder
         * 
         */
        public Builder appService(String appService) {
            return appService(Output.of(appService));
        }

        /**
         * @param autoLastHop Specifies whether auto lasthop is enabled or not
         * 
         * @return builder
         * 
         */
        public Builder autoLastHop(@Nullable Output<String> autoLastHop) {
            $.autoLastHop = autoLastHop;
            return this;
        }

        /**
         * @param autoLastHop Specifies whether auto lasthop is enabled or not
         * 
         * @return builder
         * 
         */
        public Builder autoLastHop(String autoLastHop) {
            return autoLastHop(Output.of(autoLastHop));
        }

        /**
         * @param description User defined description
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description User defined description
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param idleTimeout Specifies an idle timeout for wildcard tunnels in seconds
         * 
         * @return builder
         * 
         */
        public Builder idleTimeout(@Nullable Output<Integer> idleTimeout) {
            $.idleTimeout = idleTimeout;
            return this;
        }

        /**
         * @param idleTimeout Specifies an idle timeout for wildcard tunnels in seconds
         * 
         * @return builder
         * 
         */
        public Builder idleTimeout(Integer idleTimeout) {
            return idleTimeout(Output.of(idleTimeout));
        }

        /**
         * @param key The key field may represent different values depending on the type of the tunnel
         * 
         * @return builder
         * 
         */
        public Builder key(@Nullable Output<Integer> key) {
            $.key = key;
            return this;
        }

        /**
         * @param key The key field may represent different values depending on the type of the tunnel
         * 
         * @return builder
         * 
         */
        public Builder key(Integer key) {
            return key(Output.of(key));
        }

        /**
         * @param localAddress Specifies a local IP address. This option is required
         * 
         * @return builder
         * 
         */
        public Builder localAddress(@Nullable Output<String> localAddress) {
            $.localAddress = localAddress;
            return this;
        }

        /**
         * @param localAddress Specifies a local IP address. This option is required
         * 
         * @return builder
         * 
         */
        public Builder localAddress(String localAddress) {
            return localAddress(Output.of(localAddress));
        }

        /**
         * @param mode Specifies how the tunnel carries traffic
         * 
         * @return builder
         * 
         */
        public Builder mode(@Nullable Output<String> mode) {
            $.mode = mode;
            return this;
        }

        /**
         * @param mode Specifies how the tunnel carries traffic
         * 
         * @return builder
         * 
         */
        public Builder mode(String mode) {
            return mode(Output.of(mode));
        }

        /**
         * @param mtu Specifies the maximum transmission unit (MTU) of the tunnel
         * 
         * @return builder
         * 
         */
        public Builder mtu(@Nullable Output<Integer> mtu) {
            $.mtu = mtu;
            return this;
        }

        /**
         * @param mtu Specifies the maximum transmission unit (MTU) of the tunnel
         * 
         * @return builder
         * 
         */
        public Builder mtu(Integer mtu) {
            return mtu(Output.of(mtu));
        }

        /**
         * @param name Name of the tunnel
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the tunnel
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param partition Displays the admin-partition within which this component resides
         * 
         * @return builder
         * 
         */
        public Builder partition(@Nullable Output<String> partition) {
            $.partition = partition;
            return this;
        }

        /**
         * @param partition Displays the admin-partition within which this component resides
         * 
         * @return builder
         * 
         */
        public Builder partition(String partition) {
            return partition(Output.of(partition));
        }

        /**
         * @param profile Specifies the profile that you want to associate with the tunnel
         * 
         * @return builder
         * 
         */
        public Builder profile(@Nullable Output<String> profile) {
            $.profile = profile;
            return this;
        }

        /**
         * @param profile Specifies the profile that you want to associate with the tunnel
         * 
         * @return builder
         * 
         */
        public Builder profile(String profile) {
            return profile(Output.of(profile));
        }

        /**
         * @param remoteAddress Specifies a remote IP address
         * 
         * @return builder
         * 
         */
        public Builder remoteAddress(@Nullable Output<String> remoteAddress) {
            $.remoteAddress = remoteAddress;
            return this;
        }

        /**
         * @param remoteAddress Specifies a remote IP address
         * 
         * @return builder
         * 
         */
        public Builder remoteAddress(String remoteAddress) {
            return remoteAddress(Output.of(remoteAddress));
        }

        /**
         * @param secondaryAddress Specifies a secondary non-floating IP address when the local-address is set to a floating address
         * 
         * @return builder
         * 
         */
        public Builder secondaryAddress(@Nullable Output<String> secondaryAddress) {
            $.secondaryAddress = secondaryAddress;
            return this;
        }

        /**
         * @param secondaryAddress Specifies a secondary non-floating IP address when the local-address is set to a floating address
         * 
         * @return builder
         * 
         */
        public Builder secondaryAddress(String secondaryAddress) {
            return secondaryAddress(Output.of(secondaryAddress));
        }

        /**
         * @param tos Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
         * 
         * @return builder
         * 
         */
        public Builder tos(@Nullable Output<String> tos) {
            $.tos = tos;
            return this;
        }

        /**
         * @param tos Specifies a value for insertion into the Type of Service (ToS) octet within the IP header of the encapsulating header of transmitted packets
         * 
         * @return builder
         * 
         */
        public Builder tos(String tos) {
            return tos(Output.of(tos));
        }

        /**
         * @param trafficGroup Specifies a traffic-group for use with the tunnel
         * 
         * @return builder
         * 
         */
        public Builder trafficGroup(@Nullable Output<String> trafficGroup) {
            $.trafficGroup = trafficGroup;
            return this;
        }

        /**
         * @param trafficGroup Specifies a traffic-group for use with the tunnel
         * 
         * @return builder
         * 
         */
        public Builder trafficGroup(String trafficGroup) {
            return trafficGroup(Output.of(trafficGroup));
        }

        /**
         * @param transparent Enables or disables the tunnel to be transparent
         * 
         * @return builder
         * 
         */
        public Builder transparent(@Nullable Output<String> transparent) {
            $.transparent = transparent;
            return this;
        }

        /**
         * @param transparent Enables or disables the tunnel to be transparent
         * 
         * @return builder
         * 
         */
        public Builder transparent(String transparent) {
            return transparent(Output.of(transparent));
        }

        /**
         * @param usePmtu Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
         * 
         * @return builder
         * 
         */
        public Builder usePmtu(@Nullable Output<String> usePmtu) {
            $.usePmtu = usePmtu;
            return this;
        }

        /**
         * @param usePmtu Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages
         * 
         * @return builder
         * 
         */
        public Builder usePmtu(String usePmtu) {
            return usePmtu(Output.of(usePmtu));
        }

        public NetTunnelState build() {
            return $;
        }
    }

}
