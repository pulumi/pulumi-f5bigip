# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'As3DeleteApps',
    'EventServiceDiscoveryNode',
    'FastHttpAppMonitor',
    'FastHttpAppPoolMember',
    'FastHttpAppVirtualServer',
    'FastHttpAppWafSecurityPolicy',
    'FastHttpsAppMonitor',
    'FastHttpsAppPoolMember',
    'FastHttpsAppTlsClientProfile',
    'FastHttpsAppTlsServerProfile',
    'FastHttpsAppVirtualServer',
    'FastHttpsAppWafSecurityPolicy',
    'FastTcpAppMonitor',
    'FastTcpAppPoolMember',
    'FastTcpAppVirtualServer',
    'FastUdpAppMonitor',
    'FastUdpAppPoolMember',
    'FastUdpAppVirtualServer',
    'SaasBotDefenseProfileProtectedEndpoint',
    'WafPolicyFileType',
    'WafPolicyGraphqlProfile',
    'WafPolicyGraphqlProfileDefenseAttribute',
    'WafPolicyHostName',
    'WafPolicyIpException',
    'WafPolicyPolicyBuilder',
    'WafPolicySignaturesSetting',
]

@pulumi.output_type
class As3DeleteApps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantName":
            suggest = "tenant_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in As3DeleteApps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        As3DeleteApps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        As3DeleteApps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apps: Sequence[_builtins.str],
                 tenant_name: _builtins.str):
        """
        :param Sequence[_builtins.str] apps: List of application names to delete from the specified tenant.
               
               > `delete_apps` cannot be used together with `as3_json`.
        :param _builtins.str tenant_name: Name of the tenant containing the apps to delete.
        """
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "tenant_name", tenant_name)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Sequence[_builtins.str]:
        """
        List of application names to delete from the specified tenant.

        > `delete_apps` cannot be used together with `as3_json`.
        """
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> _builtins.str:
        """
        Name of the tenant containing the apps to delete.
        """
        return pulumi.get(self, "tenant_name")


@pulumi.output_type
class EventServiceDiscoveryNode(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str id: name of node
        :param _builtins.str ip: ip of nonde
        :param _builtins.int port: port
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        name of node
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        ip of nonde
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        port
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class FastHttpAppMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorAuth":
            suggest = "monitor_auth"
        elif key == "sendString":
            suggest = "send_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastHttpAppMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastHttpAppMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastHttpAppMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: Optional[_builtins.int] = None,
                 monitor_auth: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None,
                 send_string: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.int interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        :param _builtins.bool monitor_auth: set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        :param _builtins.str password: password for web access on FAST-Generated Pool Monitor.
        :param _builtins.str response: The presence of this string anywhere in the HTTP response implies availability.
        :param _builtins.str send_string: Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        :param _builtins.str username: username for web access on FAST-Generated Pool Monitor.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if monitor_auth is not None:
            pulumi.set(__self__, "monitor_auth", monitor_auth)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if send_string is not None:
            pulumi.set(__self__, "send_string", send_string)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="monitorAuth")
    def monitor_auth(self) -> Optional[_builtins.bool]:
        """
        set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        """
        return pulumi.get(self, "monitor_auth")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        password for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The presence of this string anywhere in the HTTP response implies availability.
        """
        return pulumi.get(self, "response")

    @_builtins.property
    @pulumi.getter(name="sendString")
    def send_string(self) -> Optional[_builtins.str]:
        """
        Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "send_string")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        username for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class FastHttpAppPoolMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLimit":
            suggest = "connection_limit"
        elif key == "priorityGroup":
            suggest = "priority_group"
        elif key == "shareNodes":
            suggest = "share_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastHttpAppPoolMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastHttpAppPoolMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastHttpAppPoolMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 connection_limit: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 priority_group: Optional[_builtins.int] = None,
                 share_nodes: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] addresses: List of server address to be used for FAST-Generated Pool.
        :param _builtins.int connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param _builtins.int port: port number of serviceport to be used for FAST-Generated Pool.
        :param _builtins.int priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param _builtins.bool share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[_builtins.int]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[_builtins.int]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[_builtins.bool]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")


@pulumi.output_type
class FastHttpAppVirtualServer(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param _builtins.int port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class FastHttpAppWafSecurityPolicy(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        """
        :param _builtins.bool enable: Setting `true` will enable FAST to create WAF Security Policy.
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Setting `true` will enable FAST to create WAF Security Policy.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class FastHttpsAppMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorAuth":
            suggest = "monitor_auth"
        elif key == "sendString":
            suggest = "send_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastHttpsAppMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastHttpsAppMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastHttpsAppMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: Optional[_builtins.int] = None,
                 monitor_auth: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None,
                 send_string: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.int interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        :param _builtins.bool monitor_auth: set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        :param _builtins.str password: password for web access on FAST-Generated Pool Monitor.
        :param _builtins.str response: The presence of this string anywhere in the HTTP response implies availability.
        :param _builtins.str send_string: Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        :param _builtins.str username: username for web access on FAST-Generated Pool Monitor.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if monitor_auth is not None:
            pulumi.set(__self__, "monitor_auth", monitor_auth)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if send_string is not None:
            pulumi.set(__self__, "send_string", send_string)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="monitorAuth")
    def monitor_auth(self) -> Optional[_builtins.bool]:
        """
        set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        """
        return pulumi.get(self, "monitor_auth")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        password for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        The presence of this string anywhere in the HTTP response implies availability.
        """
        return pulumi.get(self, "response")

    @_builtins.property
    @pulumi.getter(name="sendString")
    def send_string(self) -> Optional[_builtins.str]:
        """
        Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "send_string")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        username for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class FastHttpsAppPoolMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLimit":
            suggest = "connection_limit"
        elif key == "priorityGroup":
            suggest = "priority_group"
        elif key == "shareNodes":
            suggest = "share_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastHttpsAppPoolMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastHttpsAppPoolMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastHttpsAppPoolMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 connection_limit: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 priority_group: Optional[_builtins.int] = None,
                 share_nodes: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] addresses: List of server address to be used for FAST-Generated Pool.
        :param _builtins.int connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param _builtins.int port: port number of serviceport to be used for FAST-Generated Pool.
        :param _builtins.int priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param _builtins.bool share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[_builtins.int]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[_builtins.int]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[_builtins.bool]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")


@pulumi.output_type
class FastHttpsAppTlsClientProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsCertName":
            suggest = "tls_cert_name"
        elif key == "tlsKeyName":
            suggest = "tls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastHttpsAppTlsClientProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastHttpsAppTlsClientProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastHttpsAppTlsClientProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tls_cert_name: _builtins.str,
                 tls_key_name: _builtins.str):
        """
        :param _builtins.str tls_cert_name: Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        :param _builtins.str tls_key_name: Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        pulumi.set(__self__, "tls_cert_name", tls_cert_name)
        pulumi.set(__self__, "tls_key_name", tls_key_name)

    @_builtins.property
    @pulumi.getter(name="tlsCertName")
    def tls_cert_name(self) -> _builtins.str:
        """
        Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_cert_name")

    @_builtins.property
    @pulumi.getter(name="tlsKeyName")
    def tls_key_name(self) -> _builtins.str:
        """
        Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_key_name")


@pulumi.output_type
class FastHttpsAppTlsServerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsCertName":
            suggest = "tls_cert_name"
        elif key == "tlsKeyName":
            suggest = "tls_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastHttpsAppTlsServerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastHttpsAppTlsServerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastHttpsAppTlsServerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tls_cert_name: _builtins.str,
                 tls_key_name: _builtins.str):
        """
        :param _builtins.str tls_cert_name: Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        :param _builtins.str tls_key_name: Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        pulumi.set(__self__, "tls_cert_name", tls_cert_name)
        pulumi.set(__self__, "tls_key_name", tls_key_name)

    @_builtins.property
    @pulumi.getter(name="tlsCertName")
    def tls_cert_name(self) -> _builtins.str:
        """
        Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_cert_name")

    @_builtins.property
    @pulumi.getter(name="tlsKeyName")
    def tls_key_name(self) -> _builtins.str:
        """
        Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_key_name")


@pulumi.output_type
class FastHttpsAppVirtualServer(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param _builtins.int port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class FastHttpsAppWafSecurityPolicy(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        """
        :param _builtins.bool enable: Setting `true` will enable FAST to create WAF Security Policy.
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Setting `true` will enable FAST to create WAF Security Policy.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class FastTcpAppMonitor(dict):
    def __init__(__self__, *,
                 interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class FastTcpAppPoolMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLimit":
            suggest = "connection_limit"
        elif key == "priorityGroup":
            suggest = "priority_group"
        elif key == "shareNodes":
            suggest = "share_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastTcpAppPoolMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastTcpAppPoolMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastTcpAppPoolMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 connection_limit: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 priority_group: Optional[_builtins.int] = None,
                 share_nodes: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] addresses: List of server address to be used for FAST-Generated Pool.
        :param _builtins.int connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param _builtins.int port: port number of serviceport to be used for FAST-Generated Pool.
        :param _builtins.int priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param _builtins.bool share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[_builtins.int]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[_builtins.int]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[_builtins.bool]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")


@pulumi.output_type
class FastTcpAppVirtualServer(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param _builtins.int port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class FastUdpAppMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedResponse":
            suggest = "expected_response"
        elif key == "sendString":
            suggest = "send_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastUdpAppMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastUdpAppMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastUdpAppMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expected_response: Optional[_builtins.str] = None,
                 interval: Optional[_builtins.int] = None,
                 send_string: Optional[_builtins.str] = None):
        """
        :param _builtins.str expected_response: The presence of this optional string is required in the response, if specified it confirms availability.
        :param _builtins.int interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        :param _builtins.str send_string: Optional data to be sent during each health check.
        """
        if expected_response is not None:
            pulumi.set(__self__, "expected_response", expected_response)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if send_string is not None:
            pulumi.set(__self__, "send_string", send_string)

    @_builtins.property
    @pulumi.getter(name="expectedResponse")
    def expected_response(self) -> Optional[_builtins.str]:
        """
        The presence of this optional string is required in the response, if specified it confirms availability.
        """
        return pulumi.get(self, "expected_response")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="sendString")
    def send_string(self) -> Optional[_builtins.str]:
        """
        Optional data to be sent during each health check.
        """
        return pulumi.get(self, "send_string")


@pulumi.output_type
class FastUdpAppPoolMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionLimit":
            suggest = "connection_limit"
        elif key == "priorityGroup":
            suggest = "priority_group"
        elif key == "shareNodes":
            suggest = "share_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FastUdpAppPoolMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FastUdpAppPoolMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FastUdpAppPoolMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 connection_limit: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 priority_group: Optional[_builtins.int] = None,
                 share_nodes: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] addresses: List of server address to be used for FAST-Generated Pool.
        :param _builtins.int connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param _builtins.int port: port number of serviceport to be used for FAST-Generated Pool.
        :param _builtins.int priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param _builtins.bool share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[_builtins.int]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[_builtins.int]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[_builtins.bool]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")


@pulumi.output_type
class FastUdpAppVirtualServer(dict):
    def __init__(__self__, *,
                 ip: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param _builtins.int port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SaasBotDefenseProfileProtectedEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mitigationAction":
            suggest = "mitigation_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SaasBotDefenseProfileProtectedEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SaasBotDefenseProfileProtectedEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SaasBotDefenseProfileProtectedEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 endpoint: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 mitigation_action: Optional[_builtins.str] = None,
                 post: Optional[_builtins.str] = None,
                 put: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Unique name for the protected endpoint
        :param _builtins.str endpoint: Specifies the path to the web page to be protected by BD. For example, `/login`.
        :param _builtins.str host: hostname or IP address of the web page to be protected by the Bot Defense
        :param _builtins.str mitigation_action: Specifies whether the BIG-IP or F5 XC Bot Defense handles mitigation of malicious HTTP requests. This field is enabled only if the Service Level field is set to Advanced/Premium
        :param _builtins.str post: POST field to protect the path when it has a POST method, `enabled` or `disabled`
        :param _builtins.str put: PUT field to protect the path when it has a PUT method,`enabled` or `disabled`
        """
        pulumi.set(__self__, "name", name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mitigation_action is not None:
            pulumi.set(__self__, "mitigation_action", mitigation_action)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if put is not None:
            pulumi.set(__self__, "put", put)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name for the protected endpoint
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Specifies the path to the web page to be protected by BD. For example, `/login`.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        hostname or IP address of the web page to be protected by the Bot Defense
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> Optional[_builtins.str]:
        """
        Specifies whether the BIG-IP or F5 XC Bot Defense handles mitigation of malicious HTTP requests. This field is enabled only if the Service Level field is set to Advanced/Premium
        """
        return pulumi.get(self, "mitigation_action")

    @_builtins.property
    @pulumi.getter
    def post(self) -> Optional[_builtins.str]:
        """
        POST field to protect the path when it has a POST method, `enabled` or `disabled`
        """
        return pulumi.get(self, "post")

    @_builtins.property
    @pulumi.getter
    def put(self) -> Optional[_builtins.str]:
        """
        PUT field to protect the path when it has a PUT method,`enabled` or `disabled`
        """
        return pulumi.get(self, "put")


@pulumi.output_type
class WafPolicyFileType(dict):
    def __init__(__self__, *,
                 allowed: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allowed: Determines whether the file type is allowed or disallowed. In either of these cases the VIOL_FILETYPE violation is issued (if enabled) for an incoming request- 
               * No allowed file type matched the file type of the request.
               * The file type of the request matched a disallowed file type.
        :param _builtins.str name: Specifies the file type name as appearing in the URL extension.
        :param _builtins.str type: Determines the type of the name attribute. Only when setting the type to `wildcard` will the special wildcard characters in the name be interpreted as such
        """
        if allowed is not None:
            pulumi.set(__self__, "allowed", allowed)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def allowed(self) -> Optional[_builtins.bool]:
        """
        Determines whether the file type is allowed or disallowed. In either of these cases the VIOL_FILETYPE violation is issued (if enabled) for an incoming request- 
        * No allowed file type matched the file type of the request.
        * The file type of the request matched a disallowed file type.
        """
        return pulumi.get(self, "allowed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the file type name as appearing in the URL extension.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Determines the type of the name attribute. Only when setting the type to `wildcard` will the special wildcard characters in the name be interpreted as such
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WafPolicyGraphqlProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attackSignaturesCheck":
            suggest = "attack_signatures_check"
        elif key == "defenseAttributes":
            suggest = "defense_attributes"
        elif key == "metacharElementcheck":
            suggest = "metachar_elementcheck"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WafPolicyGraphqlProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WafPolicyGraphqlProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WafPolicyGraphqlProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 attack_signatures_check: Optional[_builtins.bool] = None,
                 defense_attributes: Optional[Sequence['outputs.WafPolicyGraphqlProfileDefenseAttribute']] = None,
                 metachar_elementcheck: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        :param _builtins.bool attack_signatures_check: Specifies when checked (enabled) that you want attack signatures and threat campaigns to be detected on this GraphQL profile and possibly override the security policy settings of an attack signature or threat campaign specifically for this GraphQL profile. After you enable this setting, the system displays a list of attack signatures and and threat campaigns. The default is enabled
        :param Sequence['WafPolicyGraphqlProfileDefenseAttributeArgs'] defense_attributes: defense_attributes settings for policy
        :param _builtins.bool metachar_elementcheck: Specifies when checked (enabled) that the system enforces the security policy settings of a meta character for the GraphQL profile. After you enable this setting, the system displays a list of meta characters. The default is enabled
        """
        pulumi.set(__self__, "name", name)
        if attack_signatures_check is not None:
            pulumi.set(__self__, "attack_signatures_check", attack_signatures_check)
        if defense_attributes is not None:
            pulumi.set(__self__, "defense_attributes", defense_attributes)
        if metachar_elementcheck is not None:
            pulumi.set(__self__, "metachar_elementcheck", metachar_elementcheck)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="attackSignaturesCheck")
    def attack_signatures_check(self) -> Optional[_builtins.bool]:
        """
        Specifies when checked (enabled) that you want attack signatures and threat campaigns to be detected on this GraphQL profile and possibly override the security policy settings of an attack signature or threat campaign specifically for this GraphQL profile. After you enable this setting, the system displays a list of attack signatures and and threat campaigns. The default is enabled
        """
        return pulumi.get(self, "attack_signatures_check")

    @_builtins.property
    @pulumi.getter(name="defenseAttributes")
    def defense_attributes(self) -> Optional[Sequence['outputs.WafPolicyGraphqlProfileDefenseAttribute']]:
        """
        defense_attributes settings for policy
        """
        return pulumi.get(self, "defense_attributes")

    @_builtins.property
    @pulumi.getter(name="metacharElementcheck")
    def metachar_elementcheck(self) -> Optional[_builtins.bool]:
        """
        Specifies when checked (enabled) that the system enforces the security policy settings of a meta character for the GraphQL profile. After you enable this setting, the system displays a list of meta characters. The default is enabled
        """
        return pulumi.get(self, "metachar_elementcheck")


@pulumi.output_type
class WafPolicyGraphqlProfileDefenseAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowIntrospectionQueries":
            suggest = "allow_introspection_queries"
        elif key == "maximumBatchedQueries":
            suggest = "maximum_batched_queries"
        elif key == "maximumStructureDepth":
            suggest = "maximum_structure_depth"
        elif key == "maximumTotalLength":
            suggest = "maximum_total_length"
        elif key == "maximumValueLength":
            suggest = "maximum_value_length"
        elif key == "tolerateParsingWarnings":
            suggest = "tolerate_parsing_warnings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WafPolicyGraphqlProfileDefenseAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WafPolicyGraphqlProfileDefenseAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WafPolicyGraphqlProfileDefenseAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_introspection_queries: Optional[_builtins.bool] = None,
                 maximum_batched_queries: Optional[_builtins.str] = None,
                 maximum_structure_depth: Optional[_builtins.str] = None,
                 maximum_total_length: Optional[_builtins.str] = None,
                 maximum_value_length: Optional[_builtins.str] = None,
                 tolerate_parsing_warnings: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_introspection_queries: Introspection queries can also be enforced to prevent attackers from using them to
               understand the API structure and potentially breach an application.
        :param _builtins.str maximum_batched_queries: Specifies the highest number of batched queries allowed by the security policy.
        :param _builtins.str maximum_structure_depth: Specifies the greatest nesting depth found in the GraphQL structure allowed by the security policy.
        :param _builtins.str maximum_total_length: Specifies the longest length, in bytes, allowed by the security policy of the request payload, or parameter value, where the GraphQL data was found.
        :param _builtins.str maximum_value_length: Specifies the longest length (in bytes) of the longest GraphQL element value in the document allowed by the security policy.
        :param _builtins.bool tolerate_parsing_warnings: Specifies, when checked (enabled), that the system does not report when the security enforcer encounters warnings while parsing GraphQL content. Specifies when cleared (disabled), that the security policy reports when the security enforcer encounters warnings while parsing GraphQL content. The default setting is disabled.
        """
        if allow_introspection_queries is not None:
            pulumi.set(__self__, "allow_introspection_queries", allow_introspection_queries)
        if maximum_batched_queries is not None:
            pulumi.set(__self__, "maximum_batched_queries", maximum_batched_queries)
        if maximum_structure_depth is not None:
            pulumi.set(__self__, "maximum_structure_depth", maximum_structure_depth)
        if maximum_total_length is not None:
            pulumi.set(__self__, "maximum_total_length", maximum_total_length)
        if maximum_value_length is not None:
            pulumi.set(__self__, "maximum_value_length", maximum_value_length)
        if tolerate_parsing_warnings is not None:
            pulumi.set(__self__, "tolerate_parsing_warnings", tolerate_parsing_warnings)

    @_builtins.property
    @pulumi.getter(name="allowIntrospectionQueries")
    def allow_introspection_queries(self) -> Optional[_builtins.bool]:
        """
        Introspection queries can also be enforced to prevent attackers from using them to
        understand the API structure and potentially breach an application.
        """
        return pulumi.get(self, "allow_introspection_queries")

    @_builtins.property
    @pulumi.getter(name="maximumBatchedQueries")
    def maximum_batched_queries(self) -> Optional[_builtins.str]:
        """
        Specifies the highest number of batched queries allowed by the security policy.
        """
        return pulumi.get(self, "maximum_batched_queries")

    @_builtins.property
    @pulumi.getter(name="maximumStructureDepth")
    def maximum_structure_depth(self) -> Optional[_builtins.str]:
        """
        Specifies the greatest nesting depth found in the GraphQL structure allowed by the security policy.
        """
        return pulumi.get(self, "maximum_structure_depth")

    @_builtins.property
    @pulumi.getter(name="maximumTotalLength")
    def maximum_total_length(self) -> Optional[_builtins.str]:
        """
        Specifies the longest length, in bytes, allowed by the security policy of the request payload, or parameter value, where the GraphQL data was found.
        """
        return pulumi.get(self, "maximum_total_length")

    @_builtins.property
    @pulumi.getter(name="maximumValueLength")
    def maximum_value_length(self) -> Optional[_builtins.str]:
        """
        Specifies the longest length (in bytes) of the longest GraphQL element value in the document allowed by the security policy.
        """
        return pulumi.get(self, "maximum_value_length")

    @_builtins.property
    @pulumi.getter(name="tolerateParsingWarnings")
    def tolerate_parsing_warnings(self) -> Optional[_builtins.bool]:
        """
        Specifies, when checked (enabled), that the system does not report when the security enforcer encounters warnings while parsing GraphQL content. Specifies when cleared (disabled), that the security policy reports when the security enforcer encounters warnings while parsing GraphQL content. The default setting is disabled.
        """
        return pulumi.get(self, "tolerate_parsing_warnings")


@pulumi.output_type
class WafPolicyHostName(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WafPolicyIpException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipMask":
            suggest = "ip_mask"
        elif key == "blockRequests":
            suggest = "block_requests"
        elif key == "ignoreAnomalies":
            suggest = "ignore_anomalies"
        elif key == "ignoreIpreputation":
            suggest = "ignore_ipreputation"
        elif key == "trustedbyPolicybuilder":
            suggest = "trustedby_policybuilder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WafPolicyIpException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WafPolicyIpException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WafPolicyIpException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 ip_mask: _builtins.str,
                 block_requests: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 ignore_anomalies: Optional[_builtins.bool] = None,
                 ignore_ipreputation: Optional[_builtins.bool] = None,
                 trustedby_policybuilder: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ip_address: Specifies the IP address that you want the system to trust.
        :param _builtins.str ip_mask: Specifies the netmask of the exceptional IP address. This is an optional field.
        :param _builtins.str block_requests: Specifies how the system responds to blocking requests sent from this IP address. Possible options [`always`, `never`, `policy-default`].
        :param _builtins.str description: Specifies the description of the policy.
        :param _builtins.bool ignore_anomalies: Specifies when enabled that the system considers this IP address legitimate and does not take it into account when performing brute force prevention.
        :param _builtins.bool ignore_ipreputation: Specifies when enabled that the system considers this IP address legitimate even if it is found in the IP Intelligence database (a database of questionable IP addresses).
        :param _builtins.bool trustedby_policybuilder: Specifies when enabled the Policy Builder considers traffic from this IP address as being safe.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_mask", ip_mask)
        if block_requests is not None:
            pulumi.set(__self__, "block_requests", block_requests)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_anomalies is not None:
            pulumi.set(__self__, "ignore_anomalies", ignore_anomalies)
        if ignore_ipreputation is not None:
            pulumi.set(__self__, "ignore_ipreputation", ignore_ipreputation)
        if trustedby_policybuilder is not None:
            pulumi.set(__self__, "trustedby_policybuilder", trustedby_policybuilder)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        Specifies the IP address that you want the system to trust.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> _builtins.str:
        """
        Specifies the netmask of the exceptional IP address. This is an optional field.
        """
        return pulumi.get(self, "ip_mask")

    @_builtins.property
    @pulumi.getter(name="blockRequests")
    def block_requests(self) -> Optional[_builtins.str]:
        """
        Specifies how the system responds to blocking requests sent from this IP address. Possible options [`always`, `never`, `policy-default`].
        """
        return pulumi.get(self, "block_requests")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ignoreAnomalies")
    def ignore_anomalies(self) -> Optional[_builtins.bool]:
        """
        Specifies when enabled that the system considers this IP address legitimate and does not take it into account when performing brute force prevention.
        """
        return pulumi.get(self, "ignore_anomalies")

    @_builtins.property
    @pulumi.getter(name="ignoreIpreputation")
    def ignore_ipreputation(self) -> Optional[_builtins.bool]:
        """
        Specifies when enabled that the system considers this IP address legitimate even if it is found in the IP Intelligence database (a database of questionable IP addresses).
        """
        return pulumi.get(self, "ignore_ipreputation")

    @_builtins.property
    @pulumi.getter(name="trustedbyPolicybuilder")
    def trustedby_policybuilder(self) -> Optional[_builtins.bool]:
        """
        Specifies when enabled the Policy Builder considers traffic from this IP address as being safe.
        """
        return pulumi.get(self, "trustedby_policybuilder")


@pulumi.output_type
class WafPolicyPolicyBuilder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "learningMode":
            suggest = "learning_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WafPolicyPolicyBuilder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WafPolicyPolicyBuilder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WafPolicyPolicyBuilder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 learning_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str learning_mode: learning mode setting for policy-builder, possible options: [`automatic`,`disabled`, `manual`]
        """
        if learning_mode is not None:
            pulumi.set(__self__, "learning_mode", learning_mode)

    @_builtins.property
    @pulumi.getter(name="learningMode")
    def learning_mode(self) -> Optional[_builtins.str]:
        """
        learning mode setting for policy-builder, possible options: [`automatic`,`disabled`, `manual`]
        """
        return pulumi.get(self, "learning_mode")


@pulumi.output_type
class WafPolicySignaturesSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placesignaturesInStaging":
            suggest = "placesignatures_in_staging"
        elif key == "signatureStaging":
            suggest = "signature_staging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WafPolicySignaturesSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WafPolicySignaturesSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WafPolicySignaturesSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placesignatures_in_staging: Optional[_builtins.bool] = None,
                 signature_staging: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool signature_staging: setting true will enforce all signature from staging
        """
        if placesignatures_in_staging is not None:
            pulumi.set(__self__, "placesignatures_in_staging", placesignatures_in_staging)
        if signature_staging is not None:
            pulumi.set(__self__, "signature_staging", signature_staging)

    @_builtins.property
    @pulumi.getter(name="placesignaturesInStaging")
    def placesignatures_in_staging(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "placesignatures_in_staging")

    @_builtins.property
    @pulumi.getter(name="signatureStaging")
    def signature_staging(self) -> Optional[_builtins.bool]:
        """
        setting true will enforce all signature from staging
        """
        return pulumi.get(self, "signature_staging")


