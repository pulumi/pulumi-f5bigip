# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'As3DeleteAppsArgs',
    'As3DeleteAppsArgsDict',
    'EventServiceDiscoveryNodeArgs',
    'EventServiceDiscoveryNodeArgsDict',
    'FastHttpAppMonitorArgs',
    'FastHttpAppMonitorArgsDict',
    'FastHttpAppPoolMemberArgs',
    'FastHttpAppPoolMemberArgsDict',
    'FastHttpAppVirtualServerArgs',
    'FastHttpAppVirtualServerArgsDict',
    'FastHttpAppWafSecurityPolicyArgs',
    'FastHttpAppWafSecurityPolicyArgsDict',
    'FastHttpsAppMonitorArgs',
    'FastHttpsAppMonitorArgsDict',
    'FastHttpsAppPoolMemberArgs',
    'FastHttpsAppPoolMemberArgsDict',
    'FastHttpsAppTlsClientProfileArgs',
    'FastHttpsAppTlsClientProfileArgsDict',
    'FastHttpsAppTlsServerProfileArgs',
    'FastHttpsAppTlsServerProfileArgsDict',
    'FastHttpsAppVirtualServerArgs',
    'FastHttpsAppVirtualServerArgsDict',
    'FastHttpsAppWafSecurityPolicyArgs',
    'FastHttpsAppWafSecurityPolicyArgsDict',
    'FastTcpAppMonitorArgs',
    'FastTcpAppMonitorArgsDict',
    'FastTcpAppPoolMemberArgs',
    'FastTcpAppPoolMemberArgsDict',
    'FastTcpAppVirtualServerArgs',
    'FastTcpAppVirtualServerArgsDict',
    'FastUdpAppMonitorArgs',
    'FastUdpAppMonitorArgsDict',
    'FastUdpAppPoolMemberArgs',
    'FastUdpAppPoolMemberArgsDict',
    'FastUdpAppVirtualServerArgs',
    'FastUdpAppVirtualServerArgsDict',
    'SaasBotDefenseProfileProtectedEndpointArgs',
    'SaasBotDefenseProfileProtectedEndpointArgsDict',
    'WafPolicyFileTypeArgs',
    'WafPolicyFileTypeArgsDict',
    'WafPolicyGraphqlProfileArgs',
    'WafPolicyGraphqlProfileArgsDict',
    'WafPolicyGraphqlProfileDefenseAttributeArgs',
    'WafPolicyGraphqlProfileDefenseAttributeArgsDict',
    'WafPolicyHostNameArgs',
    'WafPolicyHostNameArgsDict',
    'WafPolicyIpExceptionArgs',
    'WafPolicyIpExceptionArgsDict',
    'WafPolicyPolicyBuilderArgs',
    'WafPolicyPolicyBuilderArgsDict',
    'WafPolicySignaturesSettingArgs',
    'WafPolicySignaturesSettingArgsDict',
]

MYPY = False

if not MYPY:
    class As3DeleteAppsArgsDict(TypedDict):
        apps: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of application names to delete from the specified tenant.

        > `delete_apps` cannot be used together with `as3_json`.
        """
        tenant_name: pulumi.Input[_builtins.str]
        """
        Name of the tenant containing the apps to delete.
        """
elif False:
    As3DeleteAppsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class As3DeleteAppsArgs:
    def __init__(__self__, *,
                 apps: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 tenant_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] apps: List of application names to delete from the specified tenant.
               
               > `delete_apps` cannot be used together with `as3_json`.
        :param pulumi.Input[_builtins.str] tenant_name: Name of the tenant containing the apps to delete.
        """
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "tenant_name", tenant_name)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of application names to delete from the specified tenant.

        > `delete_apps` cannot be used together with `as3_json`.
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "apps", value)

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the tenant containing the apps to delete.
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_name", value)


if not MYPY:
    class EventServiceDiscoveryNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        name of node
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        ip of nonde
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        port
        """
elif False:
    EventServiceDiscoveryNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventServiceDiscoveryNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: name of node
        :param pulumi.Input[_builtins.str] ip: ip of nonde
        :param pulumi.Input[_builtins.int] port: port
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        name of node
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ip of nonde
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class FastHttpAppMonitorArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        monitor_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        password for web access on FAST-Generated Pool Monitor.
        """
        response: NotRequired[pulumi.Input[_builtins.str]]
        """
        The presence of this string anywhere in the HTTP response implies availability.
        """
        send_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        username for web access on FAST-Generated Pool Monitor.
        """
elif False:
    FastHttpAppMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpAppMonitorArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 monitor_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input[_builtins.str]] = None,
                 send_string: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.bool] monitor_auth: set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        :param pulumi.Input[_builtins.str] password: password for web access on FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.str] response: The presence of this string anywhere in the HTTP response implies availability.
        :param pulumi.Input[_builtins.str] send_string: Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.str] username: username for web access on FAST-Generated Pool Monitor.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if monitor_auth is not None:
            pulumi.set(__self__, "monitor_auth", monitor_auth)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if send_string is not None:
            pulumi.set(__self__, "send_string", send_string)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="monitorAuth")
    def monitor_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        """
        return pulumi.get(self, "monitor_auth")

    @monitor_auth.setter
    def monitor_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "monitor_auth", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        password for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The presence of this string anywhere in the HTTP response implies availability.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter(name="sendString")
    def send_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "send_string")

    @send_string.setter
    def send_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_string", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        username for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class FastHttpAppPoolMemberArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of server address to be used for FAST-Generated Pool.
        """
        connection_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        priority_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        share_nodes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
elif False:
    FastHttpAppPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpAppPoolMemberArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_group: Optional[pulumi.Input[_builtins.int]] = None,
                 share_nodes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: List of server address to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] port: port number of serviceport to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.bool] share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @connection_limit.setter
    def connection_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_limit", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @priority_group.setter
    def priority_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_group", value)

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")

    @share_nodes.setter
    def share_nodes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "share_nodes", value)


if not MYPY:
    class FastHttpAppVirtualServerArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        port: pulumi.Input[_builtins.int]
        """
        Port number to used for accessing virtual server/application
        """
elif False:
    FastHttpAppVirtualServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpAppVirtualServerArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param pulumi.Input[_builtins.int] port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class FastHttpAppWafSecurityPolicyArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Setting `true` will enable FAST to create WAF Security Policy.
        """
elif False:
    FastHttpAppWafSecurityPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpAppWafSecurityPolicyArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enable: Setting `true` will enable FAST to create WAF Security Policy.
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Setting `true` will enable FAST to create WAF Security Policy.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class FastHttpsAppMonitorArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        monitor_auth: NotRequired[pulumi.Input[_builtins.bool]]
        """
        set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        password for web access on FAST-Generated Pool Monitor.
        """
        response: NotRequired[pulumi.Input[_builtins.str]]
        """
        The presence of this string anywhere in the HTTP response implies availability.
        """
        send_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        username for web access on FAST-Generated Pool Monitor.
        """
elif False:
    FastHttpsAppMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpsAppMonitorArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 monitor_auth: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input[_builtins.str]] = None,
                 send_string: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.bool] monitor_auth: set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        :param pulumi.Input[_builtins.str] password: password for web access on FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.str] response: The presence of this string anywhere in the HTTP response implies availability.
        :param pulumi.Input[_builtins.str] send_string: Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.str] username: username for web access on FAST-Generated Pool Monitor.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if monitor_auth is not None:
            pulumi.set(__self__, "monitor_auth", monitor_auth)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if send_string is not None:
            pulumi.set(__self__, "send_string", send_string)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="monitorAuth")
    def monitor_auth(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        set `true` if the servers require login credentials for web access on FAST-Generated Pool Monitor. default is `false`.
        """
        return pulumi.get(self, "monitor_auth")

    @monitor_auth.setter
    def monitor_auth(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "monitor_auth", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        password for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The presence of this string anywhere in the HTTP response implies availability.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter(name="sendString")
    def send_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify data to be sent during each health check for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "send_string")

    @send_string.setter
    def send_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_string", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        username for web access on FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class FastHttpsAppPoolMemberArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of server address to be used for FAST-Generated Pool.
        """
        connection_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        priority_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        share_nodes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
elif False:
    FastHttpsAppPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpsAppPoolMemberArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_group: Optional[pulumi.Input[_builtins.int]] = None,
                 share_nodes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: List of server address to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] port: port number of serviceport to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.bool] share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @connection_limit.setter
    def connection_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_limit", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @priority_group.setter
    def priority_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_group", value)

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")

    @share_nodes.setter
    def share_nodes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "share_nodes", value)


if not MYPY:
    class FastHttpsAppTlsClientProfileArgsDict(TypedDict):
        tls_cert_name: pulumi.Input[_builtins.str]
        """
        Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        """
        tls_key_name: pulumi.Input[_builtins.str]
        """
        Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
elif False:
    FastHttpsAppTlsClientProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpsAppTlsClientProfileArgs:
    def __init__(__self__, *,
                 tls_cert_name: pulumi.Input[_builtins.str],
                 tls_key_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] tls_cert_name: Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        :param pulumi.Input[_builtins.str] tls_key_name: Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        pulumi.set(__self__, "tls_cert_name", tls_cert_name)
        pulumi.set(__self__, "tls_key_name", tls_key_name)

    @_builtins.property
    @pulumi.getter(name="tlsCertName")
    def tls_cert_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_cert_name")

    @tls_cert_name.setter
    def tls_cert_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_cert_name", value)

    @_builtins.property
    @pulumi.getter(name="tlsKeyName")
    def tls_key_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_key_name")

    @tls_key_name.setter
    def tls_key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_key_name", value)


if not MYPY:
    class FastHttpsAppTlsServerProfileArgsDict(TypedDict):
        tls_cert_name: pulumi.Input[_builtins.str]
        """
        Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        """
        tls_key_name: pulumi.Input[_builtins.str]
        """
        Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
elif False:
    FastHttpsAppTlsServerProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpsAppTlsServerProfileArgs:
    def __init__(__self__, *,
                 tls_cert_name: pulumi.Input[_builtins.str],
                 tls_key_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] tls_cert_name: Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        :param pulumi.Input[_builtins.str] tls_key_name: Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        pulumi.set(__self__, "tls_cert_name", tls_cert_name)
        pulumi.set(__self__, "tls_key_name", tls_key_name)

    @_builtins.property
    @pulumi.getter(name="tlsCertName")
    def tls_cert_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of existing BIG-IP SSL certificate to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_cert_name")

    @tls_cert_name.setter
    def tls_cert_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_cert_name", value)

    @_builtins.property
    @pulumi.getter(name="tlsKeyName")
    def tls_key_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of existing BIG-IP SSL Key to be used for FAST-Generated TLS Server Profile.
        """
        return pulumi.get(self, "tls_key_name")

    @tls_key_name.setter
    def tls_key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_key_name", value)


if not MYPY:
    class FastHttpsAppVirtualServerArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        port: pulumi.Input[_builtins.int]
        """
        Port number to used for accessing virtual server/application
        """
elif False:
    FastHttpsAppVirtualServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpsAppVirtualServerArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param pulumi.Input[_builtins.int] port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class FastHttpsAppWafSecurityPolicyArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Setting `true` will enable FAST to create WAF Security Policy.
        """
elif False:
    FastHttpsAppWafSecurityPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastHttpsAppWafSecurityPolicyArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enable: Setting `true` will enable FAST to create WAF Security Policy.
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Setting `true` will enable FAST to create WAF Security Policy.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class FastTcpAppMonitorArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
elif False:
    FastTcpAppMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastTcpAppMonitorArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class FastTcpAppPoolMemberArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of server address to be used for FAST-Generated Pool.
        """
        connection_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        priority_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        share_nodes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
elif False:
    FastTcpAppPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastTcpAppPoolMemberArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_group: Optional[pulumi.Input[_builtins.int]] = None,
                 share_nodes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: List of server address to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] port: port number of serviceport to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.bool] share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @connection_limit.setter
    def connection_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_limit", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @priority_group.setter
    def priority_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_group", value)

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")

    @share_nodes.setter
    def share_nodes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "share_nodes", value)


if not MYPY:
    class FastTcpAppVirtualServerArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        port: pulumi.Input[_builtins.int]
        """
        Port number to used for accessing virtual server/application
        """
elif False:
    FastTcpAppVirtualServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastTcpAppVirtualServerArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param pulumi.Input[_builtins.int] port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class FastUdpAppMonitorArgsDict(TypedDict):
        expected_response: NotRequired[pulumi.Input[_builtins.str]]
        """
        The presence of this optional string is required in the response, if specified it confirms availability.
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        send_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional data to be sent during each health check.
        """
elif False:
    FastUdpAppMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastUdpAppMonitorArgs:
    def __init__(__self__, *,
                 expected_response: Optional[pulumi.Input[_builtins.str]] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 send_string: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expected_response: The presence of this optional string is required in the response, if specified it confirms availability.
        :param pulumi.Input[_builtins.int] interval: Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        :param pulumi.Input[_builtins.str] send_string: Optional data to be sent during each health check.
        """
        if expected_response is not None:
            pulumi.set(__self__, "expected_response", expected_response)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if send_string is not None:
            pulumi.set(__self__, "send_string", send_string)

    @_builtins.property
    @pulumi.getter(name="expectedResponse")
    def expected_response(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The presence of this optional string is required in the response, if specified it confirms availability.
        """
        return pulumi.get(self, "expected_response")

    @expected_response.setter
    def expected_response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_response", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set the time between health checks,in seconds for FAST-Generated Pool Monitor.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="sendString")
    def send_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional data to be sent during each health check.
        """
        return pulumi.get(self, "send_string")

    @send_string.setter
    def send_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "send_string", value)


if not MYPY:
    class FastUdpAppPoolMemberArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of server address to be used for FAST-Generated Pool.
        """
        connection_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        priority_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        share_nodes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
elif False:
    FastUdpAppPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastUdpAppPoolMemberArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 connection_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 priority_group: Optional[pulumi.Input[_builtins.int]] = None,
                 share_nodes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] addresses: List of server address to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] connection_limit: connectionLimit value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] port: port number of serviceport to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.int] priority_group: priorityGroup value to be used for FAST-Generated Pool.
        :param pulumi.Input[_builtins.bool] share_nodes: shareNodes value to be used for FAST-Generated Pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority_group is not None:
            pulumi.set(__self__, "priority_group", priority_group)
        if share_nodes is not None:
            pulumi.set(__self__, "share_nodes", share_nodes)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of server address to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        connectionLimit value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "connection_limit")

    @connection_limit.setter
    def connection_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connection_limit", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        port number of serviceport to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="priorityGroup")
    def priority_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        priorityGroup value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "priority_group")

    @priority_group.setter
    def priority_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority_group", value)

    @_builtins.property
    @pulumi.getter(name="shareNodes")
    def share_nodes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        shareNodes value to be used for FAST-Generated Pool.
        """
        return pulumi.get(self, "share_nodes")

    @share_nodes.setter
    def share_nodes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "share_nodes", value)


if not MYPY:
    class FastUdpAppVirtualServerArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        port: pulumi.Input[_builtins.int]
        """
        Port number to used for accessing virtual server/application
        """
elif False:
    FastUdpAppVirtualServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FastUdpAppVirtualServerArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] ip: IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        :param pulumi.Input[_builtins.int] port: Port number to used for accessing virtual server/application
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP4/IPv6 address to be used for virtual server ex: `10.1.1.1`
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port number to used for accessing virtual server/application
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class SaasBotDefenseProfileProtectedEndpointArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for the protected endpoint
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path to the web page to be protected by BD. For example, `/login`.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        hostname or IP address of the web page to be protected by the Bot Defense
        """
        mitigation_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether the BIG-IP or F5 XC Bot Defense handles mitigation of malicious HTTP requests. This field is enabled only if the Service Level field is set to Advanced/Premium
        """
        post: NotRequired[pulumi.Input[_builtins.str]]
        """
        POST field to protect the path when it has a POST method, `enabled` or `disabled`
        """
        put: NotRequired[pulumi.Input[_builtins.str]]
        """
        PUT field to protect the path when it has a PUT method,`enabled` or `disabled`
        """
elif False:
    SaasBotDefenseProfileProtectedEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SaasBotDefenseProfileProtectedEndpointArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 mitigation_action: Optional[pulumi.Input[_builtins.str]] = None,
                 post: Optional[pulumi.Input[_builtins.str]] = None,
                 put: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for the protected endpoint
        :param pulumi.Input[_builtins.str] endpoint: Specifies the path to the web page to be protected by BD. For example, `/login`.
        :param pulumi.Input[_builtins.str] host: hostname or IP address of the web page to be protected by the Bot Defense
        :param pulumi.Input[_builtins.str] mitigation_action: Specifies whether the BIG-IP or F5 XC Bot Defense handles mitigation of malicious HTTP requests. This field is enabled only if the Service Level field is set to Advanced/Premium
        :param pulumi.Input[_builtins.str] post: POST field to protect the path when it has a POST method, `enabled` or `disabled`
        :param pulumi.Input[_builtins.str] put: PUT field to protect the path when it has a PUT method,`enabled` or `disabled`
        """
        pulumi.set(__self__, "name", name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mitigation_action is not None:
            pulumi.set(__self__, "mitigation_action", mitigation_action)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if put is not None:
            pulumi.set(__self__, "put", put)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for the protected endpoint
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path to the web page to be protected by BD. For example, `/login`.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        hostname or IP address of the web page to be protected by the Bot Defense
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether the BIG-IP or F5 XC Bot Defense handles mitigation of malicious HTTP requests. This field is enabled only if the Service Level field is set to Advanced/Premium
        """
        return pulumi.get(self, "mitigation_action")

    @mitigation_action.setter
    def mitigation_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mitigation_action", value)

    @_builtins.property
    @pulumi.getter
    def post(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        POST field to protect the path when it has a POST method, `enabled` or `disabled`
        """
        return pulumi.get(self, "post")

    @post.setter
    def post(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "post", value)

    @_builtins.property
    @pulumi.getter
    def put(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        PUT field to protect the path when it has a PUT method,`enabled` or `disabled`
        """
        return pulumi.get(self, "put")

    @put.setter
    def put(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "put", value)


if not MYPY:
    class WafPolicyFileTypeArgsDict(TypedDict):
        allowed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether the file type is allowed or disallowed. In either of these cases the VIOL_FILETYPE violation is issued (if enabled) for an incoming request- 
        * No allowed file type matched the file type of the request.
        * The file type of the request matched a disallowed file type.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the file type name as appearing in the URL extension.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the type of the name attribute. Only when setting the type to `wildcard` will the special wildcard characters in the name be interpreted as such
        """
elif False:
    WafPolicyFileTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicyFileTypeArgs:
    def __init__(__self__, *,
                 allowed: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allowed: Determines whether the file type is allowed or disallowed. In either of these cases the VIOL_FILETYPE violation is issued (if enabled) for an incoming request- 
               * No allowed file type matched the file type of the request.
               * The file type of the request matched a disallowed file type.
        :param pulumi.Input[_builtins.str] name: Specifies the file type name as appearing in the URL extension.
        :param pulumi.Input[_builtins.str] type: Determines the type of the name attribute. Only when setting the type to `wildcard` will the special wildcard characters in the name be interpreted as such
        """
        if allowed is not None:
            pulumi.set(__self__, "allowed", allowed)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def allowed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the file type is allowed or disallowed. In either of these cases the VIOL_FILETYPE violation is issued (if enabled) for an incoming request- 
        * No allowed file type matched the file type of the request.
        * The file type of the request matched a disallowed file type.
        """
        return pulumi.get(self, "allowed")

    @allowed.setter
    def allowed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allowed", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the file type name as appearing in the URL extension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the type of the name attribute. Only when setting the type to `wildcard` will the special wildcard characters in the name be interpreted as such
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WafPolicyGraphqlProfileArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        attack_signatures_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies when checked (enabled) that you want attack signatures and threat campaigns to be detected on this GraphQL profile and possibly override the security policy settings of an attack signature or threat campaign specifically for this GraphQL profile. After you enable this setting, the system displays a list of attack signatures and and threat campaigns. The default is enabled
        """
        defense_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WafPolicyGraphqlProfileDefenseAttributeArgsDict']]]]
        """
        defense_attributes settings for policy
        """
        metachar_elementcheck: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies when checked (enabled) that the system enforces the security policy settings of a meta character for the GraphQL profile. After you enable this setting, the system displays a list of meta characters. The default is enabled
        """
elif False:
    WafPolicyGraphqlProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicyGraphqlProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 attack_signatures_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 defense_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['WafPolicyGraphqlProfileDefenseAttributeArgs']]]] = None,
                 metachar_elementcheck: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        :param pulumi.Input[_builtins.bool] attack_signatures_check: Specifies when checked (enabled) that you want attack signatures and threat campaigns to be detected on this GraphQL profile and possibly override the security policy settings of an attack signature or threat campaign specifically for this GraphQL profile. After you enable this setting, the system displays a list of attack signatures and and threat campaigns. The default is enabled
        :param pulumi.Input[Sequence[pulumi.Input['WafPolicyGraphqlProfileDefenseAttributeArgs']]] defense_attributes: defense_attributes settings for policy
        :param pulumi.Input[_builtins.bool] metachar_elementcheck: Specifies when checked (enabled) that the system enforces the security policy settings of a meta character for the GraphQL profile. After you enable this setting, the system displays a list of meta characters. The default is enabled
        """
        pulumi.set(__self__, "name", name)
        if attack_signatures_check is not None:
            pulumi.set(__self__, "attack_signatures_check", attack_signatures_check)
        if defense_attributes is not None:
            pulumi.set(__self__, "defense_attributes", defense_attributes)
        if metachar_elementcheck is not None:
            pulumi.set(__self__, "metachar_elementcheck", metachar_elementcheck)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="attackSignaturesCheck")
    def attack_signatures_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies when checked (enabled) that you want attack signatures and threat campaigns to be detected on this GraphQL profile and possibly override the security policy settings of an attack signature or threat campaign specifically for this GraphQL profile. After you enable this setting, the system displays a list of attack signatures and and threat campaigns. The default is enabled
        """
        return pulumi.get(self, "attack_signatures_check")

    @attack_signatures_check.setter
    def attack_signatures_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "attack_signatures_check", value)

    @_builtins.property
    @pulumi.getter(name="defenseAttributes")
    def defense_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WafPolicyGraphqlProfileDefenseAttributeArgs']]]]:
        """
        defense_attributes settings for policy
        """
        return pulumi.get(self, "defense_attributes")

    @defense_attributes.setter
    def defense_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WafPolicyGraphqlProfileDefenseAttributeArgs']]]]):
        pulumi.set(self, "defense_attributes", value)

    @_builtins.property
    @pulumi.getter(name="metacharElementcheck")
    def metachar_elementcheck(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies when checked (enabled) that the system enforces the security policy settings of a meta character for the GraphQL profile. After you enable this setting, the system displays a list of meta characters. The default is enabled
        """
        return pulumi.get(self, "metachar_elementcheck")

    @metachar_elementcheck.setter
    def metachar_elementcheck(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "metachar_elementcheck", value)


if not MYPY:
    class WafPolicyGraphqlProfileDefenseAttributeArgsDict(TypedDict):
        allow_introspection_queries: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Introspection queries can also be enforced to prevent attackers from using them to
        understand the API structure and potentially breach an application.
        """
        maximum_batched_queries: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the highest number of batched queries allowed by the security policy.
        """
        maximum_structure_depth: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the greatest nesting depth found in the GraphQL structure allowed by the security policy.
        """
        maximum_total_length: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the longest length, in bytes, allowed by the security policy of the request payload, or parameter value, where the GraphQL data was found.
        """
        maximum_value_length: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the longest length (in bytes) of the longest GraphQL element value in the document allowed by the security policy.
        """
        tolerate_parsing_warnings: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies, when checked (enabled), that the system does not report when the security enforcer encounters warnings while parsing GraphQL content. Specifies when cleared (disabled), that the security policy reports when the security enforcer encounters warnings while parsing GraphQL content. The default setting is disabled.
        """
elif False:
    WafPolicyGraphqlProfileDefenseAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicyGraphqlProfileDefenseAttributeArgs:
    def __init__(__self__, *,
                 allow_introspection_queries: Optional[pulumi.Input[_builtins.bool]] = None,
                 maximum_batched_queries: Optional[pulumi.Input[_builtins.str]] = None,
                 maximum_structure_depth: Optional[pulumi.Input[_builtins.str]] = None,
                 maximum_total_length: Optional[pulumi.Input[_builtins.str]] = None,
                 maximum_value_length: Optional[pulumi.Input[_builtins.str]] = None,
                 tolerate_parsing_warnings: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_introspection_queries: Introspection queries can also be enforced to prevent attackers from using them to
               understand the API structure and potentially breach an application.
        :param pulumi.Input[_builtins.str] maximum_batched_queries: Specifies the highest number of batched queries allowed by the security policy.
        :param pulumi.Input[_builtins.str] maximum_structure_depth: Specifies the greatest nesting depth found in the GraphQL structure allowed by the security policy.
        :param pulumi.Input[_builtins.str] maximum_total_length: Specifies the longest length, in bytes, allowed by the security policy of the request payload, or parameter value, where the GraphQL data was found.
        :param pulumi.Input[_builtins.str] maximum_value_length: Specifies the longest length (in bytes) of the longest GraphQL element value in the document allowed by the security policy.
        :param pulumi.Input[_builtins.bool] tolerate_parsing_warnings: Specifies, when checked (enabled), that the system does not report when the security enforcer encounters warnings while parsing GraphQL content. Specifies when cleared (disabled), that the security policy reports when the security enforcer encounters warnings while parsing GraphQL content. The default setting is disabled.
        """
        if allow_introspection_queries is not None:
            pulumi.set(__self__, "allow_introspection_queries", allow_introspection_queries)
        if maximum_batched_queries is not None:
            pulumi.set(__self__, "maximum_batched_queries", maximum_batched_queries)
        if maximum_structure_depth is not None:
            pulumi.set(__self__, "maximum_structure_depth", maximum_structure_depth)
        if maximum_total_length is not None:
            pulumi.set(__self__, "maximum_total_length", maximum_total_length)
        if maximum_value_length is not None:
            pulumi.set(__self__, "maximum_value_length", maximum_value_length)
        if tolerate_parsing_warnings is not None:
            pulumi.set(__self__, "tolerate_parsing_warnings", tolerate_parsing_warnings)

    @_builtins.property
    @pulumi.getter(name="allowIntrospectionQueries")
    def allow_introspection_queries(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Introspection queries can also be enforced to prevent attackers from using them to
        understand the API structure and potentially breach an application.
        """
        return pulumi.get(self, "allow_introspection_queries")

    @allow_introspection_queries.setter
    def allow_introspection_queries(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_introspection_queries", value)

    @_builtins.property
    @pulumi.getter(name="maximumBatchedQueries")
    def maximum_batched_queries(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the highest number of batched queries allowed by the security policy.
        """
        return pulumi.get(self, "maximum_batched_queries")

    @maximum_batched_queries.setter
    def maximum_batched_queries(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_batched_queries", value)

    @_builtins.property
    @pulumi.getter(name="maximumStructureDepth")
    def maximum_structure_depth(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the greatest nesting depth found in the GraphQL structure allowed by the security policy.
        """
        return pulumi.get(self, "maximum_structure_depth")

    @maximum_structure_depth.setter
    def maximum_structure_depth(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_structure_depth", value)

    @_builtins.property
    @pulumi.getter(name="maximumTotalLength")
    def maximum_total_length(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the longest length, in bytes, allowed by the security policy of the request payload, or parameter value, where the GraphQL data was found.
        """
        return pulumi.get(self, "maximum_total_length")

    @maximum_total_length.setter
    def maximum_total_length(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_total_length", value)

    @_builtins.property
    @pulumi.getter(name="maximumValueLength")
    def maximum_value_length(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the longest length (in bytes) of the longest GraphQL element value in the document allowed by the security policy.
        """
        return pulumi.get(self, "maximum_value_length")

    @maximum_value_length.setter
    def maximum_value_length(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "maximum_value_length", value)

    @_builtins.property
    @pulumi.getter(name="tolerateParsingWarnings")
    def tolerate_parsing_warnings(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies, when checked (enabled), that the system does not report when the security enforcer encounters warnings while parsing GraphQL content. Specifies when cleared (disabled), that the security policy reports when the security enforcer encounters warnings while parsing GraphQL content. The default setting is disabled.
        """
        return pulumi.get(self, "tolerate_parsing_warnings")

    @tolerate_parsing_warnings.setter
    def tolerate_parsing_warnings(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tolerate_parsing_warnings", value)


if not MYPY:
    class WafPolicyHostNameArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
elif False:
    WafPolicyHostNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicyHostNameArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique user-given name of the policy. Policy names cannot contain spaces or special characters. Allowed characters are a-z, A-Z, 0-9, dot, dash (-), colon (:) and underscore (_).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WafPolicyIpExceptionArgsDict(TypedDict):
        ip_address: pulumi.Input[_builtins.str]
        """
        Specifies the IP address that you want the system to trust.
        """
        ip_mask: pulumi.Input[_builtins.str]
        """
        Specifies the netmask of the exceptional IP address. This is an optional field.
        """
        block_requests: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how the system responds to blocking requests sent from this IP address. Possible options [`always`, `never`, `policy-default`].
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the policy.
        """
        ignore_anomalies: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies when enabled that the system considers this IP address legitimate and does not take it into account when performing brute force prevention.
        """
        ignore_ipreputation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies when enabled that the system considers this IP address legitimate even if it is found in the IP Intelligence database (a database of questionable IP addresses).
        """
        trustedby_policybuilder: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies when enabled the Policy Builder considers traffic from this IP address as being safe.
        """
elif False:
    WafPolicyIpExceptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicyIpExceptionArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 ip_mask: pulumi.Input[_builtins.str],
                 block_requests: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_anomalies: Optional[pulumi.Input[_builtins.bool]] = None,
                 ignore_ipreputation: Optional[pulumi.Input[_builtins.bool]] = None,
                 trustedby_policybuilder: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: Specifies the IP address that you want the system to trust.
        :param pulumi.Input[_builtins.str] ip_mask: Specifies the netmask of the exceptional IP address. This is an optional field.
        :param pulumi.Input[_builtins.str] block_requests: Specifies how the system responds to blocking requests sent from this IP address. Possible options [`always`, `never`, `policy-default`].
        :param pulumi.Input[_builtins.str] description: Specifies the description of the policy.
        :param pulumi.Input[_builtins.bool] ignore_anomalies: Specifies when enabled that the system considers this IP address legitimate and does not take it into account when performing brute force prevention.
        :param pulumi.Input[_builtins.bool] ignore_ipreputation: Specifies when enabled that the system considers this IP address legitimate even if it is found in the IP Intelligence database (a database of questionable IP addresses).
        :param pulumi.Input[_builtins.bool] trustedby_policybuilder: Specifies when enabled the Policy Builder considers traffic from this IP address as being safe.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_mask", ip_mask)
        if block_requests is not None:
            pulumi.set(__self__, "block_requests", block_requests)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_anomalies is not None:
            pulumi.set(__self__, "ignore_anomalies", ignore_anomalies)
        if ignore_ipreputation is not None:
            pulumi.set(__self__, "ignore_ipreputation", ignore_ipreputation)
        if trustedby_policybuilder is not None:
            pulumi.set(__self__, "trustedby_policybuilder", trustedby_policybuilder)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address that you want the system to trust.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the netmask of the exceptional IP address. This is an optional field.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_mask", value)

    @_builtins.property
    @pulumi.getter(name="blockRequests")
    def block_requests(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how the system responds to blocking requests sent from this IP address. Possible options [`always`, `never`, `policy-default`].
        """
        return pulumi.get(self, "block_requests")

    @block_requests.setter
    def block_requests(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "block_requests", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the policy.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="ignoreAnomalies")
    def ignore_anomalies(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies when enabled that the system considers this IP address legitimate and does not take it into account when performing brute force prevention.
        """
        return pulumi.get(self, "ignore_anomalies")

    @ignore_anomalies.setter
    def ignore_anomalies(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_anomalies", value)

    @_builtins.property
    @pulumi.getter(name="ignoreIpreputation")
    def ignore_ipreputation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies when enabled that the system considers this IP address legitimate even if it is found in the IP Intelligence database (a database of questionable IP addresses).
        """
        return pulumi.get(self, "ignore_ipreputation")

    @ignore_ipreputation.setter
    def ignore_ipreputation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_ipreputation", value)

    @_builtins.property
    @pulumi.getter(name="trustedbyPolicybuilder")
    def trustedby_policybuilder(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies when enabled the Policy Builder considers traffic from this IP address as being safe.
        """
        return pulumi.get(self, "trustedby_policybuilder")

    @trustedby_policybuilder.setter
    def trustedby_policybuilder(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "trustedby_policybuilder", value)


if not MYPY:
    class WafPolicyPolicyBuilderArgsDict(TypedDict):
        learning_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        learning mode setting for policy-builder, possible options: [`automatic`,`disabled`, `manual`]
        """
elif False:
    WafPolicyPolicyBuilderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicyPolicyBuilderArgs:
    def __init__(__self__, *,
                 learning_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] learning_mode: learning mode setting for policy-builder, possible options: [`automatic`,`disabled`, `manual`]
        """
        if learning_mode is not None:
            pulumi.set(__self__, "learning_mode", learning_mode)

    @_builtins.property
    @pulumi.getter(name="learningMode")
    def learning_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        learning mode setting for policy-builder, possible options: [`automatic`,`disabled`, `manual`]
        """
        return pulumi.get(self, "learning_mode")

    @learning_mode.setter
    def learning_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "learning_mode", value)


if not MYPY:
    class WafPolicySignaturesSettingArgsDict(TypedDict):
        placesignatures_in_staging: NotRequired[pulumi.Input[_builtins.bool]]
        signature_staging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        setting true will enforce all signature from staging
        """
elif False:
    WafPolicySignaturesSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WafPolicySignaturesSettingArgs:
    def __init__(__self__, *,
                 placesignatures_in_staging: Optional[pulumi.Input[_builtins.bool]] = None,
                 signature_staging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] signature_staging: setting true will enforce all signature from staging
        """
        if placesignatures_in_staging is not None:
            pulumi.set(__self__, "placesignatures_in_staging", placesignatures_in_staging)
        if signature_staging is not None:
            pulumi.set(__self__, "signature_staging", signature_staging)

    @_builtins.property
    @pulumi.getter(name="placesignaturesInStaging")
    def placesignatures_in_staging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "placesignatures_in_staging")

    @placesignatures_in_staging.setter
    def placesignatures_in_staging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "placesignatures_in_staging", value)

    @_builtins.property
    @pulumi.getter(name="signatureStaging")
    def signature_staging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        setting true will enforce all signature from staging
        """
        return pulumi.get(self, "signature_staging")

    @signature_staging.setter
    def signature_staging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "signature_staging", value)


