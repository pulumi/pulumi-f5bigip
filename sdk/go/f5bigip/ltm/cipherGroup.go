// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ltm

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// `ltm.CipherGroup` Manages F5 BIG-IP LTM cipher group using iControl REST.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/ltm"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ltm.NewCipherGroup(ctx, "test-cipher-group", &ltm.CipherGroupArgs{
//				Allows: pulumi.StringArray{
//					pulumi.String("/Common/f5-aes"),
//				},
//				Name:     pulumi.String("/Common/test-cipher-group-01"),
//				Ordering: pulumi.String("speed"),
//				Requires: pulumi.StringArray{
//					pulumi.String("/Common/f5-quic"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type CipherGroup struct {
	pulumi.CustomResourceState

	// Specifies the configuration of the allowed groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Allows pulumi.StringArrayOutput `pulumi:"allows"`
	// Specifies descriptive text that identifies the cipher rule
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Name of the Cipher group. Name should be in pattern `partition` + `cipherGroupName`
	Name pulumi.StringOutput `pulumi:"name"`
	// Controls the order of the Cipher String list in the Cipher Audit section. Options are Default, Speed, Strength, FIPS, and Hardware. The rules are processed in the order listed.
	Ordering pulumi.StringOutput `pulumi:"ordering"`
	// Specifies the configuration of the restrict groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Requires pulumi.StringArrayOutput `pulumi:"requires"`
}

// NewCipherGroup registers a new resource with the given unique name, arguments, and options.
func NewCipherGroup(ctx *pulumi.Context,
	name string, args *CipherGroupArgs, opts ...pulumi.ResourceOption) (*CipherGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CipherGroup
	err := ctx.RegisterResource("f5bigip:ltm/cipherGroup:CipherGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCipherGroup gets an existing CipherGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCipherGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CipherGroupState, opts ...pulumi.ResourceOption) (*CipherGroup, error) {
	var resource CipherGroup
	err := ctx.ReadResource("f5bigip:ltm/cipherGroup:CipherGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CipherGroup resources.
type cipherGroupState struct {
	// Specifies the configuration of the allowed groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Allows []string `pulumi:"allows"`
	// Specifies descriptive text that identifies the cipher rule
	Description *string `pulumi:"description"`
	// Name of the Cipher group. Name should be in pattern `partition` + `cipherGroupName`
	Name *string `pulumi:"name"`
	// Controls the order of the Cipher String list in the Cipher Audit section. Options are Default, Speed, Strength, FIPS, and Hardware. The rules are processed in the order listed.
	Ordering *string `pulumi:"ordering"`
	// Specifies the configuration of the restrict groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Requires []string `pulumi:"requires"`
}

type CipherGroupState struct {
	// Specifies the configuration of the allowed groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Allows pulumi.StringArrayInput
	// Specifies descriptive text that identifies the cipher rule
	Description pulumi.StringPtrInput
	// Name of the Cipher group. Name should be in pattern `partition` + `cipherGroupName`
	Name pulumi.StringPtrInput
	// Controls the order of the Cipher String list in the Cipher Audit section. Options are Default, Speed, Strength, FIPS, and Hardware. The rules are processed in the order listed.
	Ordering pulumi.StringPtrInput
	// Specifies the configuration of the restrict groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Requires pulumi.StringArrayInput
}

func (CipherGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*cipherGroupState)(nil)).Elem()
}

type cipherGroupArgs struct {
	// Specifies the configuration of the allowed groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Allows []string `pulumi:"allows"`
	// Specifies descriptive text that identifies the cipher rule
	Description *string `pulumi:"description"`
	// Name of the Cipher group. Name should be in pattern `partition` + `cipherGroupName`
	Name string `pulumi:"name"`
	// Controls the order of the Cipher String list in the Cipher Audit section. Options are Default, Speed, Strength, FIPS, and Hardware. The rules are processed in the order listed.
	Ordering *string `pulumi:"ordering"`
	// Specifies the configuration of the restrict groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Requires []string `pulumi:"requires"`
}

// The set of arguments for constructing a CipherGroup resource.
type CipherGroupArgs struct {
	// Specifies the configuration of the allowed groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Allows pulumi.StringArrayInput
	// Specifies descriptive text that identifies the cipher rule
	Description pulumi.StringPtrInput
	// Name of the Cipher group. Name should be in pattern `partition` + `cipherGroupName`
	Name pulumi.StringInput
	// Controls the order of the Cipher String list in the Cipher Audit section. Options are Default, Speed, Strength, FIPS, and Hardware. The rules are processed in the order listed.
	Ordering pulumi.StringPtrInput
	// Specifies the configuration of the restrict groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
	Requires pulumi.StringArrayInput
}

func (CipherGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cipherGroupArgs)(nil)).Elem()
}

type CipherGroupInput interface {
	pulumi.Input

	ToCipherGroupOutput() CipherGroupOutput
	ToCipherGroupOutputWithContext(ctx context.Context) CipherGroupOutput
}

func (*CipherGroup) ElementType() reflect.Type {
	return reflect.TypeOf((**CipherGroup)(nil)).Elem()
}

func (i *CipherGroup) ToCipherGroupOutput() CipherGroupOutput {
	return i.ToCipherGroupOutputWithContext(context.Background())
}

func (i *CipherGroup) ToCipherGroupOutputWithContext(ctx context.Context) CipherGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CipherGroupOutput)
}

func (i *CipherGroup) ToOutput(ctx context.Context) pulumix.Output[*CipherGroup] {
	return pulumix.Output[*CipherGroup]{
		OutputState: i.ToCipherGroupOutputWithContext(ctx).OutputState,
	}
}

// CipherGroupArrayInput is an input type that accepts CipherGroupArray and CipherGroupArrayOutput values.
// You can construct a concrete instance of `CipherGroupArrayInput` via:
//
//	CipherGroupArray{ CipherGroupArgs{...} }
type CipherGroupArrayInput interface {
	pulumi.Input

	ToCipherGroupArrayOutput() CipherGroupArrayOutput
	ToCipherGroupArrayOutputWithContext(context.Context) CipherGroupArrayOutput
}

type CipherGroupArray []CipherGroupInput

func (CipherGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CipherGroup)(nil)).Elem()
}

func (i CipherGroupArray) ToCipherGroupArrayOutput() CipherGroupArrayOutput {
	return i.ToCipherGroupArrayOutputWithContext(context.Background())
}

func (i CipherGroupArray) ToCipherGroupArrayOutputWithContext(ctx context.Context) CipherGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CipherGroupArrayOutput)
}

func (i CipherGroupArray) ToOutput(ctx context.Context) pulumix.Output[[]*CipherGroup] {
	return pulumix.Output[[]*CipherGroup]{
		OutputState: i.ToCipherGroupArrayOutputWithContext(ctx).OutputState,
	}
}

// CipherGroupMapInput is an input type that accepts CipherGroupMap and CipherGroupMapOutput values.
// You can construct a concrete instance of `CipherGroupMapInput` via:
//
//	CipherGroupMap{ "key": CipherGroupArgs{...} }
type CipherGroupMapInput interface {
	pulumi.Input

	ToCipherGroupMapOutput() CipherGroupMapOutput
	ToCipherGroupMapOutputWithContext(context.Context) CipherGroupMapOutput
}

type CipherGroupMap map[string]CipherGroupInput

func (CipherGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CipherGroup)(nil)).Elem()
}

func (i CipherGroupMap) ToCipherGroupMapOutput() CipherGroupMapOutput {
	return i.ToCipherGroupMapOutputWithContext(context.Background())
}

func (i CipherGroupMap) ToCipherGroupMapOutputWithContext(ctx context.Context) CipherGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CipherGroupMapOutput)
}

func (i CipherGroupMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*CipherGroup] {
	return pulumix.Output[map[string]*CipherGroup]{
		OutputState: i.ToCipherGroupMapOutputWithContext(ctx).OutputState,
	}
}

type CipherGroupOutput struct{ *pulumi.OutputState }

func (CipherGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CipherGroup)(nil)).Elem()
}

func (o CipherGroupOutput) ToCipherGroupOutput() CipherGroupOutput {
	return o
}

func (o CipherGroupOutput) ToCipherGroupOutputWithContext(ctx context.Context) CipherGroupOutput {
	return o
}

func (o CipherGroupOutput) ToOutput(ctx context.Context) pulumix.Output[*CipherGroup] {
	return pulumix.Output[*CipherGroup]{
		OutputState: o.OutputState,
	}
}

// Specifies the configuration of the allowed groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
func (o CipherGroupOutput) Allows() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CipherGroup) pulumi.StringArrayOutput { return v.Allows }).(pulumi.StringArrayOutput)
}

// Specifies descriptive text that identifies the cipher rule
func (o CipherGroupOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CipherGroup) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Name of the Cipher group. Name should be in pattern `partition` + `cipherGroupName`
func (o CipherGroupOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *CipherGroup) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Controls the order of the Cipher String list in the Cipher Audit section. Options are Default, Speed, Strength, FIPS, and Hardware. The rules are processed in the order listed.
func (o CipherGroupOutput) Ordering() pulumi.StringOutput {
	return o.ApplyT(func(v *CipherGroup) pulumi.StringOutput { return v.Ordering }).(pulumi.StringOutput)
}

// Specifies the configuration of the restrict groups of ciphers. You can select a cipher rule from the Available Cipher Rules list.
func (o CipherGroupOutput) Requires() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CipherGroup) pulumi.StringArrayOutput { return v.Requires }).(pulumi.StringArrayOutput)
}

type CipherGroupArrayOutput struct{ *pulumi.OutputState }

func (CipherGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CipherGroup)(nil)).Elem()
}

func (o CipherGroupArrayOutput) ToCipherGroupArrayOutput() CipherGroupArrayOutput {
	return o
}

func (o CipherGroupArrayOutput) ToCipherGroupArrayOutputWithContext(ctx context.Context) CipherGroupArrayOutput {
	return o
}

func (o CipherGroupArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*CipherGroup] {
	return pulumix.Output[[]*CipherGroup]{
		OutputState: o.OutputState,
	}
}

func (o CipherGroupArrayOutput) Index(i pulumi.IntInput) CipherGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CipherGroup {
		return vs[0].([]*CipherGroup)[vs[1].(int)]
	}).(CipherGroupOutput)
}

type CipherGroupMapOutput struct{ *pulumi.OutputState }

func (CipherGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CipherGroup)(nil)).Elem()
}

func (o CipherGroupMapOutput) ToCipherGroupMapOutput() CipherGroupMapOutput {
	return o
}

func (o CipherGroupMapOutput) ToCipherGroupMapOutputWithContext(ctx context.Context) CipherGroupMapOutput {
	return o
}

func (o CipherGroupMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*CipherGroup] {
	return pulumix.Output[map[string]*CipherGroup]{
		OutputState: o.OutputState,
	}
}

func (o CipherGroupMapOutput) MapIndex(k pulumi.StringInput) CipherGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CipherGroup {
		return vs[0].(map[string]*CipherGroup)[vs[1].(string)]
	}).(CipherGroupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CipherGroupInput)(nil)).Elem(), &CipherGroup{})
	pulumi.RegisterInputType(reflect.TypeOf((*CipherGroupArrayInput)(nil)).Elem(), CipherGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CipherGroupMapInput)(nil)).Elem(), CipherGroupMap{})
	pulumi.RegisterOutputType(CipherGroupOutput{})
	pulumi.RegisterOutputType(CipherGroupArrayOutput{})
	pulumi.RegisterOutputType(CipherGroupMapOutput{})
}
