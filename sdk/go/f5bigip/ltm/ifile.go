// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ltm

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `ltm.Ifile` This resource creates an LTM iFile on F5 BIG-IP that references an existing system iFile.
// LTM iFiles are used in iRules and LTM policies to access file content for traffic processing and decision making.
//
// ## Example Usage
//
// ### Using LTM iFile in iRule
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/ltm"
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/sys"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := sys.NewIfile(ctx, "server_list", &sys.IfileArgs{
//				Name:      pulumi.String("server-mapping"),
//				Partition: pulumi.String("Production"),
//				Content:   pulumi.String("web1:10.1.1.10\nweb2:10.1.1.11\nweb3:10.1.1.12\n"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = ltm.NewIfile(ctx, "ltm_servers", &ltm.IfileArgs{
//				Name:      pulumi.String("ltm-server-mapping"),
//				Partition: pulumi.String("Production"),
//				FileName:  pulumi.String("/Production/server-mapping"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = ltm.NewIRule(ctx, "server_selector", &ltm.IRuleArgs{
//				Name: pulumi.String("select-server-rule"),
//				Irule: pulumi.String(`when HTTP_REQUEST {
//	  set server_map [ifile get ltm-server-mapping]
//	  # Process server mapping logic
//	  foreach line [split $server_map \"\
//
//	\"] {
//	    set parts [split $line \":\"]
//	    # Implement server selection logic
//	  }
//	}
//
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Notes
//
// * The referenced system iFile (specified in `fileName`) must exist before creating the LTM iFile.
// * LTM iFiles are primarily used in iRules and LTM policies for traffic processing.
// * Changes to `name`, `partition`, or `subPath` will force recreation of the resource.
// * The LTM iFile acts as a reference to the system iFile and doesn't store content directly.
// * Use `sys.Ifile` to upload file content, then reference it with `ltm.Ifile` for LTM usage.
//
// ## Related Resources
//
// * `sys.Ifile` - Creates system iFiles with content
// * `ltm.IRule` - Creates iRules that can reference LTM iFiles
// * `ltm.Policy` - Creates LTM policies that can use LTM iFiles
//
// ## Import
//
// LTM iFiles can be imported using their full path:
//
// bash
//
// ```sh
// $ pulumi import f5bigip:ltm/ifile:Ifile example /Common/my-ltm-ifile
// ```
//
// For iFiles with sub-paths:
//
// bash
//
// ```sh
// $ pulumi import f5bigip:ltm/ifile:Ifile example /Common/templates/my-ltm-ifile
// ```
type Ifile struct {
	pulumi.CustomResourceState

	// The system iFile name to reference (e.g., `/Common/my-sys-ifile`). This should reference an existing system iFile created with `sys.Ifile`.
	FileName pulumi.StringOutput `pulumi:"fileName"`
	// The complete path of the LTM iFile on the BIG-IP system.
	FullPath pulumi.StringOutput `pulumi:"fullPath"`
	// Name of the LTM iFile to be created on BIG-IP.
	Name pulumi.StringOutput `pulumi:"name"`
	// Partition where the LTM iFile will be created. Defaults to `Common`.
	Partition pulumi.StringPtrOutput `pulumi:"partition"`
	// Subdirectory within the partition for organizing iFiles.
	SubPath pulumi.StringPtrOutput `pulumi:"subPath"`
}

// NewIfile registers a new resource with the given unique name, arguments, and options.
func NewIfile(ctx *pulumi.Context,
	name string, args *IfileArgs, opts ...pulumi.ResourceOption) (*Ifile, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FileName == nil {
		return nil, errors.New("invalid value for required argument 'FileName'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Ifile
	err := ctx.RegisterResource("f5bigip:ltm/ifile:Ifile", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIfile gets an existing Ifile resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIfile(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IfileState, opts ...pulumi.ResourceOption) (*Ifile, error) {
	var resource Ifile
	err := ctx.ReadResource("f5bigip:ltm/ifile:Ifile", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Ifile resources.
type ifileState struct {
	// The system iFile name to reference (e.g., `/Common/my-sys-ifile`). This should reference an existing system iFile created with `sys.Ifile`.
	FileName *string `pulumi:"fileName"`
	// The complete path of the LTM iFile on the BIG-IP system.
	FullPath *string `pulumi:"fullPath"`
	// Name of the LTM iFile to be created on BIG-IP.
	Name *string `pulumi:"name"`
	// Partition where the LTM iFile will be created. Defaults to `Common`.
	Partition *string `pulumi:"partition"`
	// Subdirectory within the partition for organizing iFiles.
	SubPath *string `pulumi:"subPath"`
}

type IfileState struct {
	// The system iFile name to reference (e.g., `/Common/my-sys-ifile`). This should reference an existing system iFile created with `sys.Ifile`.
	FileName pulumi.StringPtrInput
	// The complete path of the LTM iFile on the BIG-IP system.
	FullPath pulumi.StringPtrInput
	// Name of the LTM iFile to be created on BIG-IP.
	Name pulumi.StringPtrInput
	// Partition where the LTM iFile will be created. Defaults to `Common`.
	Partition pulumi.StringPtrInput
	// Subdirectory within the partition for organizing iFiles.
	SubPath pulumi.StringPtrInput
}

func (IfileState) ElementType() reflect.Type {
	return reflect.TypeOf((*ifileState)(nil)).Elem()
}

type ifileArgs struct {
	// The system iFile name to reference (e.g., `/Common/my-sys-ifile`). This should reference an existing system iFile created with `sys.Ifile`.
	FileName string `pulumi:"fileName"`
	// Name of the LTM iFile to be created on BIG-IP.
	Name string `pulumi:"name"`
	// Partition where the LTM iFile will be created. Defaults to `Common`.
	Partition *string `pulumi:"partition"`
	// Subdirectory within the partition for organizing iFiles.
	SubPath *string `pulumi:"subPath"`
}

// The set of arguments for constructing a Ifile resource.
type IfileArgs struct {
	// The system iFile name to reference (e.g., `/Common/my-sys-ifile`). This should reference an existing system iFile created with `sys.Ifile`.
	FileName pulumi.StringInput
	// Name of the LTM iFile to be created on BIG-IP.
	Name pulumi.StringInput
	// Partition where the LTM iFile will be created. Defaults to `Common`.
	Partition pulumi.StringPtrInput
	// Subdirectory within the partition for organizing iFiles.
	SubPath pulumi.StringPtrInput
}

func (IfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ifileArgs)(nil)).Elem()
}

type IfileInput interface {
	pulumi.Input

	ToIfileOutput() IfileOutput
	ToIfileOutputWithContext(ctx context.Context) IfileOutput
}

func (*Ifile) ElementType() reflect.Type {
	return reflect.TypeOf((**Ifile)(nil)).Elem()
}

func (i *Ifile) ToIfileOutput() IfileOutput {
	return i.ToIfileOutputWithContext(context.Background())
}

func (i *Ifile) ToIfileOutputWithContext(ctx context.Context) IfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileOutput)
}

// IfileArrayInput is an input type that accepts IfileArray and IfileArrayOutput values.
// You can construct a concrete instance of `IfileArrayInput` via:
//
//	IfileArray{ IfileArgs{...} }
type IfileArrayInput interface {
	pulumi.Input

	ToIfileArrayOutput() IfileArrayOutput
	ToIfileArrayOutputWithContext(context.Context) IfileArrayOutput
}

type IfileArray []IfileInput

func (IfileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ifile)(nil)).Elem()
}

func (i IfileArray) ToIfileArrayOutput() IfileArrayOutput {
	return i.ToIfileArrayOutputWithContext(context.Background())
}

func (i IfileArray) ToIfileArrayOutputWithContext(ctx context.Context) IfileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileArrayOutput)
}

// IfileMapInput is an input type that accepts IfileMap and IfileMapOutput values.
// You can construct a concrete instance of `IfileMapInput` via:
//
//	IfileMap{ "key": IfileArgs{...} }
type IfileMapInput interface {
	pulumi.Input

	ToIfileMapOutput() IfileMapOutput
	ToIfileMapOutputWithContext(context.Context) IfileMapOutput
}

type IfileMap map[string]IfileInput

func (IfileMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ifile)(nil)).Elem()
}

func (i IfileMap) ToIfileMapOutput() IfileMapOutput {
	return i.ToIfileMapOutputWithContext(context.Background())
}

func (i IfileMap) ToIfileMapOutputWithContext(ctx context.Context) IfileMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileMapOutput)
}

type IfileOutput struct{ *pulumi.OutputState }

func (IfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Ifile)(nil)).Elem()
}

func (o IfileOutput) ToIfileOutput() IfileOutput {
	return o
}

func (o IfileOutput) ToIfileOutputWithContext(ctx context.Context) IfileOutput {
	return o
}

// The system iFile name to reference (e.g., `/Common/my-sys-ifile`). This should reference an existing system iFile created with `sys.Ifile`.
func (o IfileOutput) FileName() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.FileName }).(pulumi.StringOutput)
}

// The complete path of the LTM iFile on the BIG-IP system.
func (o IfileOutput) FullPath() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.FullPath }).(pulumi.StringOutput)
}

// Name of the LTM iFile to be created on BIG-IP.
func (o IfileOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Partition where the LTM iFile will be created. Defaults to `Common`.
func (o IfileOutput) Partition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringPtrOutput { return v.Partition }).(pulumi.StringPtrOutput)
}

// Subdirectory within the partition for organizing iFiles.
func (o IfileOutput) SubPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringPtrOutput { return v.SubPath }).(pulumi.StringPtrOutput)
}

type IfileArrayOutput struct{ *pulumi.OutputState }

func (IfileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ifile)(nil)).Elem()
}

func (o IfileArrayOutput) ToIfileArrayOutput() IfileArrayOutput {
	return o
}

func (o IfileArrayOutput) ToIfileArrayOutputWithContext(ctx context.Context) IfileArrayOutput {
	return o
}

func (o IfileArrayOutput) Index(i pulumi.IntInput) IfileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Ifile {
		return vs[0].([]*Ifile)[vs[1].(int)]
	}).(IfileOutput)
}

type IfileMapOutput struct{ *pulumi.OutputState }

func (IfileMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ifile)(nil)).Elem()
}

func (o IfileMapOutput) ToIfileMapOutput() IfileMapOutput {
	return o
}

func (o IfileMapOutput) ToIfileMapOutputWithContext(ctx context.Context) IfileMapOutput {
	return o
}

func (o IfileMapOutput) MapIndex(k pulumi.StringInput) IfileOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Ifile {
		return vs[0].(map[string]*Ifile)[vs[1].(string)]
	}).(IfileOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IfileInput)(nil)).Elem(), &Ifile{})
	pulumi.RegisterInputType(reflect.TypeOf((*IfileArrayInput)(nil)).Elem(), IfileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IfileMapInput)(nil)).Elem(), IfileMap{})
	pulumi.RegisterOutputType(IfileOutput{})
	pulumi.RegisterOutputType(IfileArrayOutput{})
	pulumi.RegisterOutputType(IfileMapOutput{})
}
