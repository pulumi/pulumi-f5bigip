// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sys

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// System iFiles can be imported using their full path:
//
// bash
//
// ```sh
// $ pulumi import f5bigip:sys/ifile:Ifile example /Common/my-ifile
// ```
//
// For iFiles with sub-paths:
//
// bash
//
// ```sh
// $ pulumi import f5bigip:sys/ifile:Ifile example /Common/templates/my-ifile
// ```
type Ifile struct {
	pulumi.CustomResourceState

	// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
	Checksum pulumi.StringOutput `pulumi:"checksum"`
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content pulumi.StringOutput `pulumi:"content"`
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition pulumi.StringPtrOutput `pulumi:"partition"`
	// Size of the iFile content in bytes.
	Size pulumi.IntOutput `pulumi:"size"`
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath pulumi.StringPtrOutput `pulumi:"subPath"`
}

// NewIfile registers a new resource with the given unique name, arguments, and options.
func NewIfile(ctx *pulumi.Context,
	name string, args *IfileArgs, opts ...pulumi.ResourceOption) (*Ifile, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Content == nil {
		return nil, errors.New("invalid value for required argument 'Content'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.Content != nil {
		args.Content = pulumi.ToSecret(args.Content).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"content",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Ifile
	err := ctx.RegisterResource("f5bigip:sys/ifile:Ifile", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIfile gets an existing Ifile resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIfile(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IfileState, opts ...pulumi.ResourceOption) (*Ifile, error) {
	var resource Ifile
	err := ctx.ReadResource("f5bigip:sys/ifile:Ifile", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Ifile resources.
type ifileState struct {
	// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
	Checksum *string `pulumi:"checksum"`
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content *string `pulumi:"content"`
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition *string `pulumi:"partition"`
	// Size of the iFile content in bytes.
	Size *int `pulumi:"size"`
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath *string `pulumi:"subPath"`
}

type IfileState struct {
	// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
	Checksum pulumi.StringPtrInput
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content pulumi.StringPtrInput
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition pulumi.StringPtrInput
	// Size of the iFile content in bytes.
	Size pulumi.IntPtrInput
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath pulumi.StringPtrInput
}

func (IfileState) ElementType() reflect.Type {
	return reflect.TypeOf((*ifileState)(nil)).Elem()
}

type ifileArgs struct {
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content string `pulumi:"content"`
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name string `pulumi:"name"`
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition *string `pulumi:"partition"`
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath *string `pulumi:"subPath"`
}

// The set of arguments for constructing a Ifile resource.
type IfileArgs struct {
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content pulumi.StringInput
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name pulumi.StringInput
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition pulumi.StringPtrInput
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath pulumi.StringPtrInput
}

func (IfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ifileArgs)(nil)).Elem()
}

type IfileInput interface {
	pulumi.Input

	ToIfileOutput() IfileOutput
	ToIfileOutputWithContext(ctx context.Context) IfileOutput
}

func (*Ifile) ElementType() reflect.Type {
	return reflect.TypeOf((**Ifile)(nil)).Elem()
}

func (i *Ifile) ToIfileOutput() IfileOutput {
	return i.ToIfileOutputWithContext(context.Background())
}

func (i *Ifile) ToIfileOutputWithContext(ctx context.Context) IfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileOutput)
}

// IfileArrayInput is an input type that accepts IfileArray and IfileArrayOutput values.
// You can construct a concrete instance of `IfileArrayInput` via:
//
//	IfileArray{ IfileArgs{...} }
type IfileArrayInput interface {
	pulumi.Input

	ToIfileArrayOutput() IfileArrayOutput
	ToIfileArrayOutputWithContext(context.Context) IfileArrayOutput
}

type IfileArray []IfileInput

func (IfileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ifile)(nil)).Elem()
}

func (i IfileArray) ToIfileArrayOutput() IfileArrayOutput {
	return i.ToIfileArrayOutputWithContext(context.Background())
}

func (i IfileArray) ToIfileArrayOutputWithContext(ctx context.Context) IfileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileArrayOutput)
}

// IfileMapInput is an input type that accepts IfileMap and IfileMapOutput values.
// You can construct a concrete instance of `IfileMapInput` via:
//
//	IfileMap{ "key": IfileArgs{...} }
type IfileMapInput interface {
	pulumi.Input

	ToIfileMapOutput() IfileMapOutput
	ToIfileMapOutputWithContext(context.Context) IfileMapOutput
}

type IfileMap map[string]IfileInput

func (IfileMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ifile)(nil)).Elem()
}

func (i IfileMap) ToIfileMapOutput() IfileMapOutput {
	return i.ToIfileMapOutputWithContext(context.Background())
}

func (i IfileMap) ToIfileMapOutputWithContext(ctx context.Context) IfileMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileMapOutput)
}

type IfileOutput struct{ *pulumi.OutputState }

func (IfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Ifile)(nil)).Elem()
}

func (o IfileOutput) ToIfileOutput() IfileOutput {
	return o
}

func (o IfileOutput) ToIfileOutputWithContext(ctx context.Context) IfileOutput {
	return o
}

// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
func (o IfileOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Checksum }).(pulumi.StringOutput)
}

// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
func (o IfileOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Content }).(pulumi.StringOutput)
}

// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
func (o IfileOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Partition where the iFile will be stored. Defaults to `Common`.
func (o IfileOutput) Partition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringPtrOutput { return v.Partition }).(pulumi.StringPtrOutput)
}

// Size of the iFile content in bytes.
func (o IfileOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v *Ifile) pulumi.IntOutput { return v.Size }).(pulumi.IntOutput)
}

// Subdirectory within the partition for organizing iFiles hierarchically.
func (o IfileOutput) SubPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringPtrOutput { return v.SubPath }).(pulumi.StringPtrOutput)
}

type IfileArrayOutput struct{ *pulumi.OutputState }

func (IfileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ifile)(nil)).Elem()
}

func (o IfileArrayOutput) ToIfileArrayOutput() IfileArrayOutput {
	return o
}

func (o IfileArrayOutput) ToIfileArrayOutputWithContext(ctx context.Context) IfileArrayOutput {
	return o
}

func (o IfileArrayOutput) Index(i pulumi.IntInput) IfileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Ifile {
		return vs[0].([]*Ifile)[vs[1].(int)]
	}).(IfileOutput)
}

type IfileMapOutput struct{ *pulumi.OutputState }

func (IfileMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ifile)(nil)).Elem()
}

func (o IfileMapOutput) ToIfileMapOutput() IfileMapOutput {
	return o
}

func (o IfileMapOutput) ToIfileMapOutputWithContext(ctx context.Context) IfileMapOutput {
	return o
}

func (o IfileMapOutput) MapIndex(k pulumi.StringInput) IfileOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Ifile {
		return vs[0].(map[string]*Ifile)[vs[1].(string)]
	}).(IfileOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IfileInput)(nil)).Elem(), &Ifile{})
	pulumi.RegisterInputType(reflect.TypeOf((*IfileArrayInput)(nil)).Elem(), IfileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IfileMapInput)(nil)).Elem(), IfileMap{})
	pulumi.RegisterOutputType(IfileOutput{})
	pulumi.RegisterOutputType(IfileArrayOutput{})
	pulumi.RegisterOutputType(IfileMapOutput{})
}
