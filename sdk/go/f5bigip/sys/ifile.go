// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sys

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `sys.Ifile` This resource uploads and manages system iFiles on F5 BIG-IP devices.
// System iFiles store file content on the BIG-IP that can be referenced by iRules, LTM policies, and other BIG-IP configurations for traffic processing and decision making.
//
// ## Example Usage
//
// ### System iFile with Sub-path
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/sys"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := sys.NewIfile(ctx, "template_file", &sys.IfileArgs{
//				Name:      pulumi.String("error-template"),
//				Partition: pulumi.String("Common"),
//				SubPath:   pulumi.String("templates"),
//				Content: pulumi.String(`<html>
//	  <head><title>Service Unavailable</title></head>
//	  <body>
//	    <h1>503 - Service Temporarily Unavailable</h1>
//	    <p>Please try again later.</p>
//	  </body>
//
// </html>
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### JSON Configuration File
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/sys"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"servers": []map[string]interface{}{
//					map[string]interface{}{
//						"name": "web1",
//						"ip":   "10.1.1.10",
//						"port": 80,
//					},
//					map[string]interface{}{
//						"name": "web2",
//						"ip":   "10.1.1.11",
//						"port": 80,
//					},
//					map[string]interface{}{
//						"name": "web3",
//						"ip":   "10.1.1.12",
//						"port": 80,
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			serverList := json0
//			_, err = sys.NewIfile(ctx, "server_config", &sys.IfileArgs{
//				Name:      pulumi.String("server-list"),
//				Partition: pulumi.String("MyApp"),
//				Content:   pulumi.String(serverList),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Using System iFile with LTM iFile
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/ltm"
//	"github.com/pulumi/pulumi-f5bigip/sdk/v3/go/f5bigip/sys"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create system iFile with content
//			_, err := sys.NewIfile(ctx, "lookup_table", &sys.IfileArgs{
//				Name:      pulumi.String("url-rewrite-map"),
//				Partition: pulumi.String("Common"),
//				Content:   pulumi.String("/old-api/v1/ /api/v2/\n/legacy/ /new/\n/deprecated/ /current/\n"),
//			})
//			if err != nil {
//				return err
//			}
//			// Create LTM iFile that references the system iFile
//			_, err = ltm.NewIfile(ctx, "ltm_lookup", &ltm.IfileArgs{
//				Name:      pulumi.String("ltm-url-rewrite-map"),
//				Partition: pulumi.String("Common"),
//				FileName:  pulumi.String("/Common/url-rewrite-map"),
//			})
//			if err != nil {
//				return err
//			}
//			// Use in an iRule
//			_, err = ltm.NewIRule(ctx, "url_rewriter", &ltm.IRuleArgs{
//				Name: pulumi.String("url-rewrite-rule"),
//				Irule: pulumi.String(`when HTTP_REQUEST {
//	  set uri [HTTP::uri]
//	  set mapping [ifile get ltm-url-rewrite-map]
//	  foreach line [split $mapping \"\
//
//	\"] {
//	    set parts [split $line \" \"]
//	    if {[string match [lindex $parts 0]* $uri]} {
//	      HTTP::uri [string map [list [lindex $parts 0] [lindex $parts 1]] $uri]
//	      break
//	    }
//	  }
//	}
//
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Notes
//
// * The `content` field is marked as sensitive and will not be displayed in Terraform logs or state output.
// * Changes to `name` will force recreation of the resource since iFile names cannot be changed after creation.
// * The `checksum` and `size` attributes are automatically computed by the BIG-IP system.
// * iFile content is uploaded to the BIG-IP system and stored there permanently until the resource is destroyed.
// * Use `file()` function to load content from local files or `templatefile()` for dynamic content generation.
// * System iFiles can be referenced by `ltm.Ifile` resources for use in LTM configurations.
//
// ## Path Structure
//
// The full path of an iFile follows this pattern:
// - Without sub-path: `/{partition}/{name}`
// - With sub-path: `/{partition}/{sub_path}/{name}`
//
// Examples:
// - `/Common/config-file`
// - `/Production/templates/error-page`
// - `/MyApp/configs/database-settings`
//
// ## Related Resources
//
// * `ltm.Ifile` - Creates LTM iFiles that reference system iFiles
// * `ltm.IRule` - Creates iRules that can access iFile content
// * `ltm.Policy` - Creates LTM policies that can use iFile content
//
// ## Security Considerations
//
// * iFile content is stored on the BIG-IP system and may contain sensitive information
// * Use appropriate BIG-IP access controls to limit who can view or modify iFiles
// * Consider using Terraform's sensitive variable handling for confidential content
// * The `content` field is marked as sensitive in Terraform state to prevent accidental exposure
//
// ## Import
//
// System iFiles can be imported using their full path:
//
// For iFiles with sub-paths:
type Ifile struct {
	pulumi.CustomResourceState

	// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
	Checksum pulumi.StringOutput `pulumi:"checksum"`
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content pulumi.StringOutput `pulumi:"content"`
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition pulumi.StringPtrOutput `pulumi:"partition"`
	// Size of the iFile content in bytes.
	Size pulumi.IntOutput `pulumi:"size"`
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath pulumi.StringPtrOutput `pulumi:"subPath"`
}

// NewIfile registers a new resource with the given unique name, arguments, and options.
func NewIfile(ctx *pulumi.Context,
	name string, args *IfileArgs, opts ...pulumi.ResourceOption) (*Ifile, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Content == nil {
		return nil, errors.New("invalid value for required argument 'Content'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.Content != nil {
		args.Content = pulumi.ToSecret(args.Content).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"content",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Ifile
	err := ctx.RegisterResource("f5bigip:sys/ifile:Ifile", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIfile gets an existing Ifile resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIfile(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IfileState, opts ...pulumi.ResourceOption) (*Ifile, error) {
	var resource Ifile
	err := ctx.ReadResource("f5bigip:sys/ifile:Ifile", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Ifile resources.
type ifileState struct {
	// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
	Checksum *string `pulumi:"checksum"`
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content *string `pulumi:"content"`
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition *string `pulumi:"partition"`
	// Size of the iFile content in bytes.
	Size *int `pulumi:"size"`
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath *string `pulumi:"subPath"`
}

type IfileState struct {
	// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
	Checksum pulumi.StringPtrInput
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content pulumi.StringPtrInput
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition pulumi.StringPtrInput
	// Size of the iFile content in bytes.
	Size pulumi.IntPtrInput
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath pulumi.StringPtrInput
}

func (IfileState) ElementType() reflect.Type {
	return reflect.TypeOf((*ifileState)(nil)).Elem()
}

type ifileArgs struct {
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content string `pulumi:"content"`
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name string `pulumi:"name"`
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition *string `pulumi:"partition"`
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath *string `pulumi:"subPath"`
}

// The set of arguments for constructing a Ifile resource.
type IfileArgs struct {
	// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
	Content pulumi.StringInput
	// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
	Name pulumi.StringInput
	// Partition where the iFile will be stored. Defaults to `Common`.
	Partition pulumi.StringPtrInput
	// Subdirectory within the partition for organizing iFiles hierarchically.
	SubPath pulumi.StringPtrInput
}

func (IfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ifileArgs)(nil)).Elem()
}

type IfileInput interface {
	pulumi.Input

	ToIfileOutput() IfileOutput
	ToIfileOutputWithContext(ctx context.Context) IfileOutput
}

func (*Ifile) ElementType() reflect.Type {
	return reflect.TypeOf((**Ifile)(nil)).Elem()
}

func (i *Ifile) ToIfileOutput() IfileOutput {
	return i.ToIfileOutputWithContext(context.Background())
}

func (i *Ifile) ToIfileOutputWithContext(ctx context.Context) IfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileOutput)
}

// IfileArrayInput is an input type that accepts IfileArray and IfileArrayOutput values.
// You can construct a concrete instance of `IfileArrayInput` via:
//
//	IfileArray{ IfileArgs{...} }
type IfileArrayInput interface {
	pulumi.Input

	ToIfileArrayOutput() IfileArrayOutput
	ToIfileArrayOutputWithContext(context.Context) IfileArrayOutput
}

type IfileArray []IfileInput

func (IfileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ifile)(nil)).Elem()
}

func (i IfileArray) ToIfileArrayOutput() IfileArrayOutput {
	return i.ToIfileArrayOutputWithContext(context.Background())
}

func (i IfileArray) ToIfileArrayOutputWithContext(ctx context.Context) IfileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileArrayOutput)
}

// IfileMapInput is an input type that accepts IfileMap and IfileMapOutput values.
// You can construct a concrete instance of `IfileMapInput` via:
//
//	IfileMap{ "key": IfileArgs{...} }
type IfileMapInput interface {
	pulumi.Input

	ToIfileMapOutput() IfileMapOutput
	ToIfileMapOutputWithContext(context.Context) IfileMapOutput
}

type IfileMap map[string]IfileInput

func (IfileMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ifile)(nil)).Elem()
}

func (i IfileMap) ToIfileMapOutput() IfileMapOutput {
	return i.ToIfileMapOutputWithContext(context.Background())
}

func (i IfileMap) ToIfileMapOutputWithContext(ctx context.Context) IfileMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IfileMapOutput)
}

type IfileOutput struct{ *pulumi.OutputState }

func (IfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Ifile)(nil)).Elem()
}

func (o IfileOutput) ToIfileOutput() IfileOutput {
	return o
}

func (o IfileOutput) ToIfileOutputWithContext(ctx context.Context) IfileOutput {
	return o
}

// MD5 checksum of the iFile content, automatically calculated by BIG-IP.
func (o IfileOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Checksum }).(pulumi.StringOutput)
}

// The content of the iFile. This can be inline text, file content loaded with `file()`, or dynamically generated content. This field is marked as sensitive.
func (o IfileOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Content }).(pulumi.StringOutput)
}

// Name of the system iFile to be created on BIG-IP. Changing this forces a new resource to be created.
func (o IfileOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Partition where the iFile will be stored. Defaults to `Common`.
func (o IfileOutput) Partition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringPtrOutput { return v.Partition }).(pulumi.StringPtrOutput)
}

// Size of the iFile content in bytes.
func (o IfileOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v *Ifile) pulumi.IntOutput { return v.Size }).(pulumi.IntOutput)
}

// Subdirectory within the partition for organizing iFiles hierarchically.
func (o IfileOutput) SubPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Ifile) pulumi.StringPtrOutput { return v.SubPath }).(pulumi.StringPtrOutput)
}

type IfileArrayOutput struct{ *pulumi.OutputState }

func (IfileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Ifile)(nil)).Elem()
}

func (o IfileArrayOutput) ToIfileArrayOutput() IfileArrayOutput {
	return o
}

func (o IfileArrayOutput) ToIfileArrayOutputWithContext(ctx context.Context) IfileArrayOutput {
	return o
}

func (o IfileArrayOutput) Index(i pulumi.IntInput) IfileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Ifile {
		return vs[0].([]*Ifile)[vs[1].(int)]
	}).(IfileOutput)
}

type IfileMapOutput struct{ *pulumi.OutputState }

func (IfileMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Ifile)(nil)).Elem()
}

func (o IfileMapOutput) ToIfileMapOutput() IfileMapOutput {
	return o
}

func (o IfileMapOutput) ToIfileMapOutputWithContext(ctx context.Context) IfileMapOutput {
	return o
}

func (o IfileMapOutput) MapIndex(k pulumi.StringInput) IfileOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Ifile {
		return vs[0].(map[string]*Ifile)[vs[1].(string)]
	}).(IfileOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IfileInput)(nil)).Elem(), &Ifile{})
	pulumi.RegisterInputType(reflect.TypeOf((*IfileArrayInput)(nil)).Elem(), IfileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IfileMapInput)(nil)).Elem(), IfileMap{})
	pulumi.RegisterOutputType(IfileOutput{})
	pulumi.RegisterOutputType(IfileArrayOutput{})
	pulumi.RegisterOutputType(IfileMapOutput{})
}
